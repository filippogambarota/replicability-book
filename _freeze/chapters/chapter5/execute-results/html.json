{
  "hash": "0f080204ae80f6d4535abb676568bb7f",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute: \n  echo: true\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: \"#>\"\n---\n\n\n\n\n\n# Meta-analysis and publication bias\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Meta-analysis {.section}\n\n## Meta-analysis\n\n- The meta-analysis is a statistical procedure to combine evidence from a group of studies.\n\n. . .\n\n- The idea is to \"switch\" the statistical unit from e.g., participants to studies\n\n. . .\n\n- The motto could be that (appropriately) combining similar studies with a similar aim is the best way to understand something about a phenomenon\n\n## Meta-analysis and Systematic Review {.smaller}\n\nUsually a meta-analysis work follows these steps:\n\n1. **Identify the research question**: is the treatment *x* effective?, Does the experimental effect *y* exist?\n2. **Define inclusion/exclusion criteria**: From the research question (1), keep only e.g., randomized controlled trials, studies with healthy participants, etc.\n3. **Systematically search for studies**: Analyze the literature to find all relevant studies\n4. **Extract relevant information**: Read, extract and organize relevant information e.g., sample size, treatment type, age, etc.\n5. **Summarize the results**: Create a narrative (flowcharts, tables, etc.) summary of included studies. This is the Systematic review part.\n6. **Choose an effect size**: Choose a way to standardize the effect across included studies\n7. **Meta-analysis model**: Choose and implement a meta-analysis model\n8. **Interpret and report results**\n\n## Before the fun part...\n\n::: {.incremental}\n- We are dealing only with the **statistical part**. The study selection, data extraction, studies evaluation etc. is another story\n- The quality of the meta-analysis is the **quality of included studies**\n:::\n\n. . .\n\n![](img/gigo.png){fig-align=\"center\" width=60%}\n\n## Unstandardized effect sizes\n\nThe basic idea of an effect size is just using the raw measure. For example studies using reaction times we can calculate the difference between two conditions as $\\overline X_1 - \\overline X_2$:\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Unstandardized effect sizes\n\nBut another study (with the same research question) could use another measure, e.g., accuracy. We can still (not the best strategy but) compute the difference between the group means.\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Unstandardized effect sizes\n\nClearly we cannot directly compare the two effects but we need to standardize the measure.\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Standardized effect sizes\n\nTo compare results from different studies, we should use a common metric. Frequently meta-analysts use *standardized* effect sizes. For example the Pearson correlation or the Cohen's $d$.\n\n$$\nr = \\frac{\\sum{(x_i - \\bar{x})(y_i - \\bar{y})}}{\\sqrt{\\sum{(x_i - \\bar{x})^2}\\sum{(y_i - \\bar{y})^2}}}\n$$ {#eq-correlation}\n\n$$\nd = \\frac{\\bar{x_1} - \\bar{x_2}}{s_p}\n$$\n\n$$\ns_p = \\sqrt{\\frac{(n_1 - 1)s_1^2 + (n_2 - 1)s_2^2}{n_1 + n_2 - 2}}\n$$\n\n## Standardized effect sizes\n\nThe advantage of standardized effect size is that regardless the original variable, the interpretation and the scale is the same. For example the pearson correlation ranges between -1 and 1 and the Cohen's $d$ between $- \\infty$ and $\\infty$ and is interpreted as how many standard deviations the two groups/conditions differs.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nS <- matrix(c(1, 0.7, 0.7, 1), nrow = 2)\nX <- MASS::mvrnorm(100, c(0, 2), S, empirical = TRUE)\n\npar(mfrow = c(1,2))\nplot(X, xlab = \"x\", ylab = \"y\", cex = 1.3, pch = 19,\n     cex.lab = 1.2, cex.axis = 1.2,\n     main = latex2exp::TeX(sprintf(\"$r = %.2f$\", cor(X[, 1], X[, 2]))))\nabline(lm(X[, 2] ~ X[, 1]), col = \"firebrick\", lwd = 2)\n\n\nplot(density(X[, 1]), xlim = c(-5, 7), ylim = c(0, 0.5), col = \"dodgerblue\", lwd = 2,\n     main = latex2exp::TeX(sprintf(\"$d = %.2f$\", lsr::cohensD(X[, 1], X[, 2]))),\n     xlab = \"\")\nlines(density(X[, 2]), col = \"firebrick\", lwd = 2)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Standardized vs unstandardized\n\nThe main difference is (usually) the absence of a effect-size-variance relationship for unstandardized effects. For example, the variance of the difference between two groups is:\n\n$$\nV_d = \\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}\n$$ {#eq-var-umd}\n\nWhile the variance of a Cohen's $d$ can be calculated as:\n\n$$\nV_d = \\frac{n_1 + n_2}{n_1 n_2} + \\frac{d^2}{2(n_1 + n_2)}\n$$\n\n## Standardized vs unstandardized\n\nIn this [amazing blog post](https://www.jepusto.com/alternative-formulas-for-the-smd/) James Pustejovsky explained where the equations comes from. Basically, the $\\frac{n_1 + n_2}{n_1 n_2}$ term is the same as the $\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}$ while the extra $\\frac{d^2}{2(n_1 + n_2)}$ is for the non-centrality induced by the standardized difference.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nn <- c(10, 50, 100)\nd <- seq(0, 2, 0.001)\n\ndd <- expand.grid(n = n, d = d)\n\ndd$vumd <- with(dd, 1/n + 1/n)\ndd$vd <- with(dd, (n + n) / (n * n) + d^2/(2 * (n + n)))\n\ntidyr::pivot_longer(dd, 3:4) |> \n  ggplot(aes(x = d, y = value, color = name, linetype = factor(n))) +\n  geom_line() +\n  labs(linetype = \"Sample Size\",\n       color = NULL)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Effect size sampling variability {#sec-effsize-se}\n\nCrucially, we can calculate also the **sampling variability** of each effect size. The **sampling variability** is the precision of estimated value.\n\nFor example, there are multiple methods to estimate the Cohen's $d$ sampling variability. For example:\n\n$$\nV_d = \\frac{n_1 + n_2}{n_1 n_2} + \\frac{d^2}{2(n_1 + n_2)}\n$$\n\nEach effect size has a specific formula for the sampling variability. The sample size is usually the most important information. Studies with high sample size have low sampling variability.\n\n## Effect size sampling variability\n\nAs the sample size grows and tends to infinity, the sampling variability approach zero.\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Unstandardized effect sizes\n\nFor the examples and plots I'm going to use simulated data. We simulate *unstandardized* effect sizes (UMD) because the computations are easier and the estimator is unbiased [e.g., @Viechtbauer2005-zt]\n\nMore specifically we simulate hypothetical studies where two independent groups are compared:\n\n$$\n\\Delta = \\overline{X_1} - \\overline{X_2}\n$$ {#eq-umd}\n\n$$\nSE_{\\Delta} = \\sqrt{\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}}\n$$\n\nWith $X_{1_i} \\sim \\mathcal{N}(0, 1)$ and $X_{2_i} \\sim \\mathcal{N}(\\Delta, 1)$\n\nThe main advantage is that, compared to standardized effect size, the sampling variability do not depends on the effect size itself, simplifying the computations.\n\n# Simulating a single study {.section}\n\n## Simulating a single study - UMD\n\nTo simulate a single study using a UMD we need to generate data according to the appropriate model. Here we have a difference between two groups. We can assume that the two groups comes from a normal distribution where group 1 $g_1 \\sim \\mathcal{N}(0, 1)$ and group 2 $g_2 \\sim \\mathcal{N}(D, 1)$ where $D$ is the effect size. Then using Equations [-@eq-var-umd; -@eq-umd] we can estimate the effect size and the variance.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- 1  # effect size\nn <- 50 # sample size\ng1 <- rnorm(n, mean = 0, sd = 1)\ng2 <- rnorm(n, mean = D, sd = 1)\n\n# effect size\nmean(g2) - mean(g1)\n#> [1] 0.7428889\n\n# variance\nvar(g1)/n + var(g2)/n\n#> [1] 0.03372845\n```\n:::\n\n\n\n\n\n## Simulating a single study - UMD\n\nFor simplicity we can wrap everything within a function:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# default sd = 1\nsim_umd <- function(n1, n2 = NULL, D, sd = 1){\n  if(is.null(n2)) n2 <- n1 # same to n1 if null \n  g1 <- rnorm(n1, mean = 0, sd = sd)\n  g2 <- rnorm(n2, mean = D, sd = sd)\n  yi <- mean(g2) - mean(g1)\n  vi <- var(g1)/n1 + var(g2)/n2\n  data.frame(yi, vi)\n}\n\nsim_umd(100, D = 0.5)\n#>          yi         vi\n#> 1 0.6292466 0.02098998\nsim_umd(50, D = 0.1)\n#>          yi       vi\n#> 1 0.4147609 0.047054\n```\n:::\n\n\n\n\n\n## Simulating a single study - UMD\n\nWe can also generate a large number of studies and check the distribution of effect size and sampling variances. Note that the real $D = 1$ and the real variance $V_D = 1/50 + 1/50 = 0.04$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudies <- replicate(1000, sim_umd(n1 = 50, D = 1), simplify = FALSE) # simplify = FALSE return a list\nstudies <- do.call(rbind, studies) # to dataframe\nhead(studies)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>          yi         vi\n#> 1 1.0974008 0.04093664\n#> 2 1.0471223 0.03207823\n#> 3 1.0283730 0.04529990\n#> 4 1.1099761 0.04421705\n#> 5 0.7004132 0.04450937\n#> 6 0.7143166 0.04797191\n```\n\n\n:::\n:::\n\n\n\n\n\n## Simulating a single study - UMD {#sec-umd-sampling-distribution}\n\nThen we can plot the sampling distributions:\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Simulating a single study - SMD\n\nThe idea is the same when simulating a SDM but we need extra steps. Let's adjust the previous function:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_smd <- function(n1, n2 = NULL, D){\n  if(is.null(n2)) n2 <- n1 # same to n1 if null \n  g1 <- rnorm(n1, mean = 0, sd = 1)\n  g2 <- rnorm(n2, mean = D, sd = 1)\n  \n  v1 <- var(g1)\n  v2 <- var(g2)\n  \n  # pooled standard deviation\n  sp <- sqrt((v1 * (n1 - 1) + v2 * (n2 - 1)) / (n1 + n2 - 2))\n  \n  yi <- (mean(g2) - mean(g1)) / sp\n  vi <- (n1 + n2) / (n1 * n2) + yi^2/(2*(n1 + n2))\n  data.frame(yi, vi)\n}\n```\n:::\n\n\n\n\n\n## Simulating a single study - SMD\n\nWhen working with SMD, calculating the sampling variance can be challenging. @Veroniki2016-nw identified 16 different estimators with different properties. Furthermore, it is a common practice to correct the SDM effect and variance using the Hedges's correction [@Hedges1989-ip]. \n\nYou can directly implement another equation for the sampling variance or the Hedges's correction directly in the simulation function.\n\n## Simulating a single study - Pearson $\\rho$\n\nAnother common effect size is the Pearson correlation coefficient $\\rho$ (and the estimate $r$, see @eq-correlation). The variance of the correlation is calculated as:\n\n$$\nV_{r} = \\frac{(1 - r^2)^2}{n - 1}\n$$\n\n## Simulating a single study - Pearson $\\rho$\n\nThere is a huge dependency between $r$ and it's sampling variance (similar to the Cohen's $d$):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nn <- 50\nr <- seq(0, 1, 0.01)\nv <- (1 - r^2)^2 / (n - 1) \n\nplot(r, v, type = \"l\", main = \"N = 50\", xlab = \"r\", ylab = latex2exp::TeX(\"$V_r$\"))\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Simulating a single study - Pearson $\\rho$\n\nFor this reason the so-called Fisher's $z$ transformation is used to stabilize the relationship.\n\n$$\nz = \\frac{\\log{\\frac{1 + r}{1 - r}}}{2}\n$$\n\n$$\nV_z = \\frac{1}{n - 3}\n$$\n\nNow the variance is completely independent from the correlation value.\n\n## Simulating a single study - Pearson $\\rho$\n\nThis is the relationship between $r$ and $z$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nn <- 50\nr <- seq(-1, 1, 0.01)\nv <- (1 - r^2)^2 / (n - 1) \nz <- log((1 + r)/(1 - r))/2\n\nplot(z, r, type = \"l\", xlab = \"Fisher's z\", ylab = \"Correlation\", main = \"Correlation to Fisher's z\")\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Simulating a single study - Pearson $\\rho$\n\nTo simulate a study using correlations we can use the `MASS::mvrnorm()` function that can generate correlated data from a multivariate normal distribution.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_r <- function(n, r){\n  R <- r + diag(1 - r, nrow = 2) # 2 x 2 correlation matrix\n  X <- MASS::mvrnorm(n, mu = c(0, 0), Sigma = R) # the means are not relevant here\n  r <- cor(X)[1, 2] # extract correlation\n  vr <- (1 - r^2)^2 / (n - 1)  # variance of r\n  yi <- log((1 + r)/(1 - r))/2 # fisher z\n  vi <- 1 / (n - 3) # fisher z variance\n  data.frame(yi, vi, r, vr) # including also the pearson correlation and variance\n}\n```\n:::\n\n\n\n\n\n## Simulating a single study - Pearson $\\rho$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_r(100, 0.5)\n#>          yi         vi         r          vr\n#> 1 0.4202373 0.01030928 0.3971303 0.007166144\nsim_r(50, 0.8)\n#>         yi        vi       r          vr\n#> 1 1.099418 0.0212766 0.80029 0.002638084\n\n# also here the sampling distributions\nstudies <- replicate(1000, sim_r(50, 0.7), simplify = FALSE)\nstudies <- do.call(rbind, studies)\nsummary(studies)\n#>        yi               vi                r                vr          \n#>  Min.   :0.4589   Min.   :0.02128   Min.   :0.4292   Min.   :0.001249  \n#>  1st Qu.:0.7695   1st Qu.:0.02128   1st Qu.:0.6466   1st Qu.:0.003953  \n#>  Median :0.8686   Median :0.02128   Median :0.7007   Median :0.005289  \n#>  Mean   :0.8726   Mean   :0.02128   Mean   :0.6954   Mean   :0.005534  \n#>  3rd Qu.:0.9690   3rd Qu.:0.02128   3rd Qu.:0.7483   3rd Qu.:0.006910  \n#>  Max.   :1.3230   Max.   :0.02128   Max.   :0.8675   Max.   :0.013583\n```\n:::\n\n\n\n\n\n## More on effect sizes\n\nThe same logic can be applied to any situation. Just understand the data generation process, find the effect size equations and generate data.\n\n- @Borenstein2009-mo for all effect sizes equations. Also with equations to convert among effect sizes (useful in real-world meta-analyses)   \n- the [`metafor::escalc()`](https://wviechtb.github.io/metafor/reference/escalc.html) function implements basically any effect size. You can see also the [source code](https://github.com/wviechtb/metafor/blob/master/R/escalc.r) to see the actual R implementation.\n- [Guide to effect sizes](https://matthewbjane.quarto.pub/guide-to-effect-sizes-and-confidence-intervals): a modern and complete overview of effect sizes\n\n## Simulating from sampling distributions [#extra]\n\nThe previous simulation examples are participant-level simulations. In fact we simulated $n$ observations then we aggregated calculating the effect sizes.\n\n. . .\n\nThis is the most flexible and general data simulation strategy but is computationally not efficient.\n\n. . .\n\nAnother strategy individuate the exact effect size sampling distribution. Then we can sample directly from it. The downside is that we need to derive (or find) the equation.\n\n## Simulating from sampling distributions [#extra]\n\nFor example, when generating UMD we can simulate from the sampling distribution presented in @sec-umd-sampling-distribution.\n\n$$\ny_i \\sim \\mathcal{N}(\\theta, \\sqrt{\\sigma^2_i})\n$$\n$$\n\\sigma^2_i \\sim \\frac{\\chi^2_{n_1 + n_2 - 2}}{n_1 + n_2 - 2} (\\frac{1}{n_1} + \\frac{1}{n_2})\n$$\n\nIn this way we can sample $k$ effects and sampling variances directly from the sampling distributions. Without generating data and then aggregate.\n\n## Simulating from sampling distributions [#extra]\n\nWe can again put everything within a function:\n\n```r\nsim_k_umd <- function(k, D, n1, n2 = NULL){\n  if(is.null(n2)) n2 <- n1\n  yi <- rnorm(k, D, sqrt(1/n1 + 1/n2))\n  vi <- (rchisq(k, n1 + n2 - 2) / (n1 + n2 - 2)) * (1/n1 + 1/n2)\n  data.frame(yi, vi)\n}\n```\n\n## Simulating from sampling distributions [#extra]\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_k_umd(k = 10, D = 0.5, n1 = 50)\n#>            yi         vi\n#> 1  0.59626901 0.03651621\n#> 2  0.29367154 0.04243381\n#> 3  0.55988406 0.05268682\n#> 4  0.36752058 0.04880525\n#> 5  0.05553809 0.03851076\n#> 6  0.54829084 0.04382554\n#> 7  0.31989788 0.03740828\n#> 8  0.56871934 0.04222310\n#> 9  0.20966467 0.04416763\n#> 10 0.73415866 0.03596558\n```\n:::\n\n\n\n\n\n## Simulating from sampling distributions [#extra]\n\nWe can compare the two methods and see that we are sampling from the same data generation process.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nk <- 1e4\ns_umd <- sim_k_umd(k, D = 1, n1 = 50)\nip_umd <- replicate(k, sim_umd(n1 = 50, D = 1), simplify = FALSE)\nip_umd <- do.call(rbind, ip_umd)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Simulating from sampling distributions [#extra]\n\nThe actual advantage is in terms of computational speed. To simulate $k = 10$ studies for 1000 times (similar to a standard Monte Carlo simulation):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench <- microbenchmark::microbenchmark(\n  sampling = sim_k_umd(k = 10, n1 = 50, D = 1),\n  participant = replicate(10, sim_umd(n1 = 50, D = 1)),\n  times = 1000 \n)\n\n(bench <- summary(bench))\n#>          expr      min       lq      mean   median        uq      max neval cld\n#> 1    sampling  121.468  127.109  135.6278  131.628  138.0295  263.506  1000  a \n#> 2 participant 1532.892 1566.545 1659.8272 1593.727 1610.3680 6359.687  1000   b\n\nbench$mean[2] / bench$mean[1] # faster\n#> [1] 12.2381\n```\n:::\n\n\n\n\n\n# Simulation setup {.section}\n\n## Notation {.smaller}\n\nMeta-analysis notation is a little bit inconsistent in textbooks and papers. We define here some rules to simplify the work.\n\n- $k$ is the number of studies\n- $n_j$ is the sample size of the group $j$ within a study\n- $y_i$ are the observed effect size included in the meta-analysis\n- $\\sigma_i^2$ are the observed sampling variance of studies and $\\epsilon_i$ are the sampling errors\n- $\\theta$ is the equal-effects parameter (see @eq-ee1)\n- $\\delta_i$ is the random-effect (see @eq-re-mod2)\n- $\\mu_\\theta$ is the average effect of a random-effects model (see @eq-re-mod1)\n- $w_i$ are the meta-analysis weights\n- $\\tau^2$ is the heterogeneity (see @eq-re-mod2)\n- $\\Delta$ is the (generic) population effect size\n- $s_j^2$ is the variance of the group $j$ within a study\n\n## Simulation setup\n\nGiven the introduction to effect sizes, from now we will simulate data using UMD and the individual-level data. \n\nBasically we are simulating an effect size $D$ coming from the comparison of two independent groups $G_1$ and $G_2$.\n\nEach group is composed by $n$ participants measured on a numerical outcome (e.g., reaction times)\n\n## Simulation setup\n\nA more general, clear and realistic approach to simulate data is by generating $k$ studies with same/different sample sizes and (later) true effect sizes.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 10 # number of studies\nn1 <- n2 <- 10 + rpois(k, 30 - 10) # sample size from poisson distribution with lambda 40 and minimum 10\nD <- 0.5 # effect size\n\nyi <- rep(NA, k)\nvi <- rep(NA, k)\n  \nfor(i in 1:k){\n  g1 <- rnorm(n1[i], 0, 1)\n  g2 <- rnorm(n2[i], D, 1)\n  yi[i] <- mean(g2) - mean(g1)\n  vi[i] <- var(g1)/n1[i] + var(g2)/n2[i]\n}\n  \nsim <- data.frame(id = 1:k, yi, vi)\n\nhead(sim)\n#>   id          yi         vi\n#> 1  1  0.32347839 0.08199370\n#> 2  2 -0.06229478 0.09007477\n#> 3  3  0.42661729 0.06047760\n#> 4  4  0.99254822 0.06154313\n#> 5  5  0.28434245 0.04539959\n#> 6  6  0.06321880 0.08937580\n```\n:::\n\n\n\n\n\n## Simulation setup\n\nWe can again put everything within a function:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_studies <- function(k, es, n1, n2 = NULL){\n  if(length(n1) == 1) n1 <- rep(n1, k)\n  if(is.null(n2)) n2 <- n1\n  if(length(es) == 1) es <- rep(es, k)\n  \n  yi <- rep(NA, k)\n  vi <- rep(NA, k)\n  \n  for(i in 1:k){\n    g1 <- rnorm(n1[i], 0, 1)\n    g2 <- rnorm(n2[i], es[i], 1)\n    yi[i] <- mean(g2) - mean(g1)\n    vi[i] <- var(g1)/n1[i] + var(g2)/n2[i]\n  }\n  \n  sim <- data.frame(id = 1:k, yi, vi, n1 = n1, n2 = n2)\n  \n  # convert to escalc for using metafor methods\n  sim <- metafor::escalc(yi = yi, vi = vi, data = sim)\n  \n  return(sim)\n}\n```\n:::\n\n\n\n\n\n## Simulation setup - Disclaimer\n\nThe proposed simulation approach using a `for` loop and separated vectors. For the purpose of the workshop this is the best option. In real-world meta-analysis simulations you can choose a more functional approach starting from a simulation grid as `data.frame` and mapping the simulation functions.\n\nFor some examples see:\n\n- @Gambarota2023-on\n- [www.jepusto.com/simulating-correlated-smds](https://www.jepusto.com/simulating-correlated-smds)\n\n## Simulation setup - Disclaimer\n\nFor a more extended overview of the simulation setup we have an entire paper. Supplementary materials ([github.com/shared-research/simulating-meta-analysis](https://github.com/shared-research/simulating-meta-analysis)) contains also more examples for complex (multilevel and multivariate models.)\n\n![](img/gambarota2023.png){fig-align=\"center\"}\n\n# Combining studies {.section}\n\n## Combining studies\n\nLet's imagine to have $k = 10$ studies, a $D = 0.5$ and heterogeneous sample sizes in each study.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 10\nD <- 0.5\nn <- 10 + rpois(k, lambda = 20) \ndat <- sim_studies(k = k, es = D, n1 = n)\nhead(dat)\n#> \n#>   id     yi     vi n1 n2 \n#> 1  1 0.2457 0.0614 32 32 \n#> 2  2 0.4531 0.0645 38 38 \n#> 3  3 0.1710 0.0829 19 19 \n#> 4  4 0.5329 0.0673 31 31 \n#> 5  5 0.4363 0.0539 26 26 \n#> 6  6 0.3225 0.0526 40 40\n```\n:::\n\n\n\n\n\n. . .\n\nWhat is the best way to combine the studies?\n\n## Combining studies\n\nWe can take the average effect size and considering it as a huge study. This can be considered the best way to combine the effects.\n\n$$\n\\hat{D} = \\frac{\\sum^{k}_{i = 1} D_i}{k}\n$$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(dat$yi)\n#> [1] 0.3595696\n```\n:::\n\n\n\n\n\n. . .\n\nIt is appropriate? What do you think? Are we missing something?\n\n## Weighting studies\n\nWe are not considering that some studies, despite providing a similar effect size could give more information. An higher sample size (or lower sampling variance) produce a more reliable estimation.\n\n. . .\n\nWould you trust more a study with $n = 100$ and $D = 0.5$ or a study with $n = 10$ and $D = 0.5$? The \"meta-analysis\" that we did before is completely ignoring this information.\n\n## Weighting studies\n\nWe need to find a value (called weight $w_i$) that allows assigning more trust to a study because it provide more information. \n\n. . .\n\nThe simplest weights are just the sample size, but in practice we use the so-called **inverse-variance weighting**. We use the (inverse) of the sampling variance of the effect size to weight each study. \n\n. . .\n\nThe basic version of a meta-analysis is just a **weighted average**:\n\n$$\n\\overline D_w = \\frac{\\sum^k_{i = 1}{w_iD_i}}{\\sum^k_{i = 1}{w_i}}\n$$\n\n. . .\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwi <- 1/dat$vi\nsum(dat$yi * wi) / sum(wi)\n#> [1] 0.3663024\n# weighted.mean(dat$yi, wi)\n```\n:::\n\n\n\n\n\n## Weighting studies\n\nGraphically, the two models can be represented in this way:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndw <- weighted.mean(dat$yi, 1/dat$vi)\ndunw <- mean(dat$yi)\n\nunw_plot <- ggplot(dat, aes(x = yi, y = factor(id))) +\n  geom_point(size = 3) +\n  xlim(c(-0.5, 1.5)) +\n  geom_vline(xintercept = dunw) +\n  xlab(latex2exp::TeX(\"$y_i$\")) +\n  ylab(\"Study\") +\n  theme_minimal(15) +\n  annotate(\"label\", x = 0.5, y = k + 0.4, label = latex2exp::TeX(sprintf(\"$\\\\bar{D} = %.2f$\", dunw))) +\n  geom_label(aes(x = 1, y = id, label = paste0(\"n = \", n1)))\n\nw_plot <- ggplot(dat, aes(x = yi, y = factor(id))) +\n  geom_point(aes(size = 1/vi),\n             show.legend = FALSE) +\n  xlim(c(-0.5, 1.5)) +\n  geom_vline(xintercept = dw) +\n  xlab(latex2exp::TeX(\"$y_i$\")) +\n  ylab(\"Study\") +\n  theme_minimal(15) +\n  annotate(\"label\", x = 0.5, y = k + 0.4, label = latex2exp::TeX(sprintf(\"$\\\\bar{D}_w = %.2f$\", dw))) +\n  geom_label(aes(x = 1, y = id, label = paste0(\"n = \", n1)))\n\nunw_plot + w_plot\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n\n\n# Equal-effects (EE) meta-analysis {.section}\n\n## EE meta-analysis\n\nWhat we did in the last example (the weighted mean) is the exactly a meta-analysis model called **equal-effects** (or less precisely fixed-effect). The assumptions are very simple:\n\n- there is a unique, true effect size to estimate $\\theta$\n- each study is a more or less precise estimate of $\\theta$\n- there is no TRUE variability among studies. The observed variability is due to studies that are imprecise (i.e., sampling error)\n- assuming that each study has a very large sample size, the observed variability is close to zero.\n\n## EE meta-analysis, formally\n\n$$\ny_i = \\theta + \\epsilon_i\n$$ {#eq-ee1}\n\n$$\n\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2_i)\n$$ {#eq-ee2}\n\nWhere $\\sigma^2_i$ is the vector of sampling variabilities of $k$ studies. This is a standard linear model but with heterogeneous sampling variances.\n\n## EE meta-analysis\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n<!-- TODO fix the image, ggplot version -->\n\n## Simulating an EE model\n\nWhat we were doing with the `sim_studies()` function so far was simulating an EE model. In fact, there were a single $\\theta$ parameter and the observed variability was a function of the `rnorm()` randomness.\n\nBased on previous assumptions and thinking a little bit, what could be the result of simulating studies with a very large $n$?\n\n. . .\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nns <- c(10, 50, 100, 1000, 1e4)\nD <- 0.5\ndats <- lapply(ns, function(n) sim_studies(10, es = D, n1 = n))\n```\n:::\n\n\n\n\n\n## Simulating an EE modelm {#sec-ee-impact-n}\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-30-1.png){width=1440}\n:::\n:::\n\n\n\n\n\n## Simulating an EE model\n\nFormulating the model as a intercept-only regression (see Equations [@eq-ee1] and [@eq-ee2]) we can generate data directly:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- 0.5\nn <- 30\nk <- 10\n\nyi <- D + rnorm(k, 0, sqrt(1/n + 1/n))\n# or equivalently\n# yi <- rnorm(k, D, sqrt(1/n + 1/n))\n```\n:::\n\n\n\n\n\nAs we did for the aggregated data approach. Clearly we need to simulate also the `vi` vector from the appropriate distribution. Given that we simulated data starting from the participant-level the uncertainty of `yi` and `vi` is already included.\n\n## Fitting an EE model\n\nThe model can be fitted using the `metafor::rma()` function, with `method = \"EE\"`^[There is a confusion about the *fixed-effects* vs *fixed-effect* (no *s*) and *equal-effects* models. See [https://wviechtb.github.io/metafor/reference/misc-models.html](https://wviechtb.github.io/metafor/reference/misc-models.html)].\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheta <- 0.5\nk <- 15\nn <- 10 + rpois(k, 30 - 10)\ndat <- sim_studies(k = k, es = theta, n1 = n)\nfit <- rma(yi, vi, data = dat, method = \"EE\")\nsummary(fit)\n#> \n#> Equal-Effects Model (k = 15)\n#> \n#>   logLik  deviance       AIC       BIC      AICc   \n#>  -3.2628   19.0853    8.5257    9.2337    8.8334   \n#> \n#> I^2 (total heterogeneity / total variability):   26.65%\n#> H^2 (total variability / sampling variability):  1.36\n#> \n#> Test for Heterogeneity:\n#> Q(df = 14) = 19.0853, p-val = 0.1617\n#> \n#> Model Results:\n#> \n#> estimate      se    zval    pval   ci.lb   ci.ub      \n#>   0.4590  0.0667  6.8778  <.0001  0.3282  0.5898  *** \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\n## Interpreting an EE model\n\n- The first section (`logLik`, `deviance`, etc.) presents some general model statistics and information criteria\n- The $I^2$ and $H^2$ are statistics evaluating the observed heterogeneity (see next slides)\n- The `Test of Heterogeneity` section presents the test of the $Q$ statistics for the observed heterogeneity (see next slides)\n- The `Model Results` section presents the estimation of the $\\theta$ parameter along with the standard error and the Wald $z$ test ($H_0: \\theta = 0$)\n\nThe `metafor` package has a several well documented functions to calculate and plot model results, residuals analysis etc.\n\n## Interpreting an EE model\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(fit) # general plots\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Interpreting an EE Model\n\nThe main function for plotting model results is the `forest()` function that produce the forest plot.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nforest(fit)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Interpreting an EE Model\n\nWe did not introduced the concept of heterogeneity, but the $I^2$, $H^2$ and $Q$ statistics basically evaluate if the observed heterogeneity should be attributed to **sampling variability** (uncertainty in estimating $\\theta$ because we have a limited $k$ and $n$) or **sampling variability** plus other sources of heterogeneity.\n\n## EE model as a weighted Average\n\nFormally $\\theta$ is estimated as [see @Borenstein2009-mo, p. 66]\n\n$$\n\\hat{\\theta} = \\frac{\\sum^k_{i = 1}{w_iy_i}}{\\sum^k_{i = 1}{w_i}}; \\;\\;\\; w_i = \\frac{1}{\\sigma^2_i}\n$$\n\n$$\nSE_{\\theta} = \\frac{1}{\\sum^k_{i = 1}{w_i}}\n$$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwi <- 1/dat$vi\ntheta_hat <- with(dat, sum(yi * wi)/sum(wi))\nse_theta_hat <- sqrt(1/sum(wi))\nc(theta = theta_hat, se = se_theta_hat, z = theta_hat / se_theta_hat)\n#>      theta         se          z \n#> 0.45897245 0.06673282 6.87776180\n```\n:::\n\n\n\n\n\n# Random-effects (RE) meta-analysis {.section}\n\n## Are the EE assumptions realistic?\n\nThe EE model is appropriate if our studies are somehow **exact replications** of the exact same effect. We are assuming that there is **no real variability**.\n\n. . .\n\nHowever, meta-analysis rarely report the results of $k$ exact replicates. It is more common to include **studies answering the same research question** but with different methods, participants, etc.\n\n. . .\n\n- people with different ages or other participant-level differences\n- different methodology\n- ...\n\n## Are the EE assumptions realistic?\n\n. . .\n\nIf we relax the previous assumption we are able to combine studies that are not exact replications. \n\n. . .\n\nThus the real effect $\\theta$ is no longer a single **true** value but can be larger or smaller in some conditions.\n\n. . .\n\nIn other terms we are assuming that there could be some variability (i.e., **heterogeneity**) among studies that is independent from the sample size. Even with studies with $\\lim_{n\\to\\infty}$ the observed variability is not zero.\n\n## Random-effects model (RE)\n\nWe can extend the EE model including another source of variability, $\\tau^2$. $\\tau^2$ is the true heterogeneity among studies caused by methdological differences or intrisic variability in the phenomenon.\n\nFormally we can extend @eq-ee1 as:\n$$\ny_i = \\mu_{\\theta} + \\delta_i + \\epsilon_i\n$$ {#eq-re-mod1}\n\n$$\n\\delta_i \\sim \\mathcal{N}(0, \\tau^2)\n$$ {#eq-re-mod2}\n\n$$\n\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2_i)\n$$\n\nWhere $\\mu_{\\theta}$ is the average effect size and $\\delta_i$ is the study-specific deviation from the average effect (regulated by $\\tau^2$). Clearly each study specific effect is $\\theta_i = \\mu_{\\theta} + \\delta_i$.\n\n## RE model\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n<!-- TODO fix the image, ggplot version -->\n\n## RE model estimation\n\nGiven that we extended the EE model equation. Also the estimation of the average effect need to be extended. Basically the RE is still a weighted average but weights need to include also $\\tau^2$.\n\n$$\n\\overline y = \\frac{\\sum_{i = 1}^k y_iw^*_i}{\\sum_{i = 1}^k w^*_i}\n$$ {#eq-re1}\n\n$$\nw^*_i = \\frac{1}{\\sigma^2_i + \\tau^2}\n$$ {#eq-re2}\n\nThe weights are different compared to the EE model. Extremely precise/imprecise studies will have less impact in the RE model.\n\n## RE vs EE model\n\nThe crucial difference with the EE model is that even with large $n$, only the $\\mu_{\\theta} + \\delta_i$ are estimated (almost) without error. As long $\\tau^2 \\neq 0$ there will be variability in the effect sizes.\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n<!-- TODO fix the image, ggplot version -->\n\n## Simulating a RE Model\n\nTo simulate the RE model we simply need to include $\\tau^2$ in the EE model simulation.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 15 # number of studies\nmu <- 0.5 # average effect\ntau2 <- 0.1 # heterogeneity\nn <- 10 + rpois(k, 30 - 10) # sample size\ndeltai <- rnorm(k, 0, sqrt(tau2)) # random-effects\nthetai <- mu + deltai # true study effect\n\ndat <- sim_studies(k = k, es = thetai, n1 = n)\n\nhead(dat)\n#> \n#>   id     yi     vi n1 n2 \n#> 1  1 0.6838 0.0860 26 26 \n#> 2  2 0.4613 0.0701 34 34 \n#> 3  3 0.5666 0.0631 35 35 \n#> 4  4 0.7017 0.0705 29 29 \n#> 5  5 0.1014 0.0918 26 26 \n#> 6  6 0.6434 0.0840 27 27\n```\n:::\n\n\n\n\n\n## Simulating a RE model\n\nAgain, we can put everything within a function expanding the previous `sim_studies()` by including $\\tau^2$:\n\n\n\n\n\n\n\n\n\n\n\n```r\nsim_studies <- function(k, es, tau2 = 0, n1, n2 = NULL, add = NULL){\n  if(length(n1) == 1) n1 <- rep(n1, k)\n  if(is.null(n2)) n2 <- n1\n  if(length(es) == 1) es <- rep(es, k)\n  \n  yi <- rep(NA, k)\n  vi <- rep(NA, k)\n  \n  # random effects\n  deltai <- rnorm(k, 0, sqrt(tau2))\n  \n  for(i in 1:k){\n    g1 <- rnorm(n1[i], 0, 1)\n    g2 <- rnorm(n2[i], es[i] + deltai[i], 1)\n    yi[i] <- mean(g2) - mean(g1)\n    vi[i] <- var(g1)/n1[i] + var(g2)/n2[i]\n  }\n  \n  sim <- data.frame(id = 1:k, yi, vi, n1 = n1, n2 = n2)\n  \n  if(!is.null(add)){\n    sim <- cbind(sim, add)\n  }\n  \n  # convert to escalc for using metafor methods\n  sim <- metafor::escalc(yi = yi, vi = vi, data = sim)\n  \n  return(sim)\n}\n```\n\n## Simulating a RE model\n\nThe data are similar to the EE simulation but we have an extra source of heterogeneity.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndat |>\n  summary() |>\n  qforest()\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Simulating a RE model\n\nTo see the actual impact of $\\tau^2$ we can follow the same approach of @sec-ee-impact-n thus using a large $n$. The sampling variance `vi` of each study is basically 0.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ... other parameters as before\nn <- 1e4\ndeltai <- rnorm(k, 0, sqrt(tau2)) # random-effects\nthetai <- mu + deltai # true study effect\ndat <- sim_studies(k = k, es = thetai, n1 = n)\n# or equivalently \n# dat <- sim_studies(k = k, es = mu, tau2 = tau2, n1 = n)\n\nhead(dat)\n#> \n#>   id     yi     vi    n1    n2 \n#> 1  1 0.5474 0.0002 10000 10000 \n#> 2  2 0.0975 0.0002 10000 10000 \n#> 3  3 0.9151 0.0002 10000 10000 \n#> 4  4 0.4185 0.0002 10000 10000 \n#> 5  5 0.0186 0.0002 10000 10000 \n#> 6  6 0.1722 0.0002 10000 10000\n```\n:::\n\n\n\n\n\n## Simulating a RE Model\n\nClearly, compared to @sec-ee-impact-n, even with large $n$ the variability is not reduced because $\\tau^2 \\neq 0$. As $\\tau^2$ approach zero the EE and RE models are similar.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndat |>\n  summary() |>\n  qforest()\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## RE model estimation\n\nGiven that we extended the EE model equation. Also the estimation of the average effect need to be extended. Basically the RE is still a weighted average but weights need to include also $\\tau^2$.\n\n$$\n\\overline y = \\frac{\\sum_{i = 1}^k y_iw^*_i}{\\sum_{i = 1}^k w^*_i}\n$$ {#eq-re1}\n\n$$\nw^*_i = \\frac{1}{\\sigma^2_i + \\tau^2}\n$$ {#eq-re2}\n\nThe weights are different compared to the EE model. Extremely precise/imprecise studies will have less impact in the RE model.\n\n## Fitting a RE model\n\nIn R we can use the `metafor::rma()` function using the `method = \"REML\"`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- rma(yi, vi, data = dat, method = \"REML\")\nsummary(fit)\n#> \n#> Random-Effects Model (k = 15; tau^2 estimator: REML)\n#> \n#>   logLik  deviance       AIC       BIC      AICc   \n#>  -7.8430   15.6860   19.6860   20.9641   20.7769   \n#> \n#> tau^2 (estimated amount of total heterogeneity): 0.1793 (SE = 0.0679)\n#> tau (square root of estimated tau^2 value):      0.4235\n#> I^2 (total heterogeneity / total variability):   99.89%\n#> H^2 (total variability / sampling variability):  898.45\n#> \n#> Test for Heterogeneity:\n#> Q(df = 14) = 12514.0313, p-val < .0001\n#> \n#> Model Results:\n#> \n#> estimate      se    zval    pval   ci.lb   ci.ub      \n#>   0.5501  0.1094  5.0287  <.0001  0.3357  0.7646  *** \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\n## Intepreting the RE model\n\nThe model output is quite similar to the EE model and also the intepretation is similar.\n\nThe only extra section is `tau^2/tau` that is the estimation of the between-study heterogeneity.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fit)\n#> \n#> Random-Effects Model (k = 15; tau^2 estimator: REML)\n#> \n#>   logLik  deviance       AIC       BIC      AICc   \n#>  -7.8430   15.6860   19.6860   20.9641   20.7769   \n#> \n#> tau^2 (estimated amount of total heterogeneity): 0.1793 (SE = 0.0679)\n#> tau (square root of estimated tau^2 value):      0.4235\n#> I^2 (total heterogeneity / total variability):   99.89%\n#> H^2 (total variability / sampling variability):  898.45\n#> \n#> Test for Heterogeneity:\n#> Q(df = 14) = 12514.0313, p-val < .0001\n#> \n#> Model Results:\n#> \n#> estimate      se    zval    pval   ci.lb   ci.ub      \n#>   0.5501  0.1094  5.0287  <.0001  0.3357  0.7646  *** \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\n\n## Estimating $\\tau^2$\n\n\n![](img/langan2017.png){fig-align=\"center\" width=80%}\n\n## Estimating $\\tau^2$\n\nThe **Restricted Maximum Likelihood** (REML) estimator is considered one of the best. We can compare the results using the `all_rma()` custom function that tests all the estimators^[The `filor::compare_rma()` function is similar to the `car::compareCoefs()` function].\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfitl <- all_rma(fit)\nround(filor::compare_rma(fitlist = fitl), 3)\n#>           DL     HE     HS    HSk     SJ     ML   REML     EB     PM    PMM\n#> b      0.550  0.550  0.550  0.550  0.550  0.550  0.550  0.550  0.550  0.550\n#> se     0.109  0.109  0.105  0.109  0.109  0.106  0.109  0.109  0.109  0.112\n#> zval   5.042  5.029  5.219  5.042  5.029  5.205  5.029  5.029  5.029  4.909\n#> pval   0.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000\n#> ci.lb  0.336  0.336  0.344  0.336  0.336  0.343  0.336  0.336  0.336  0.330\n#> ci.ub  0.764  0.765  0.757  0.764  0.765  0.757  0.765  0.765  0.765  0.770\n#> I2    99.888 99.889 99.880 99.888 99.889 99.881 99.889 99.889 99.889 99.894\n#> tau2   0.178  0.179  0.166  0.178  0.179  0.167  0.179  0.179  0.179  0.188\n```\n:::\n\n\n\n\n\n## Intepreting heterogeneity $\\tau^2$\n\nLooking at @eq-re-mod2, $\\tau^2$ is essentially the variance of the random-effect. This means that we can intepret it as the variability (or the standard deviation) of the true effect size distribution.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntau2s <- c(0.01, 0.05, 0.1, 0.2)\ntau2s_t <- latex2exp::TeX(sprintf(\"$\\\\tau^2 = %.2f$\", tau2s))\n\npar(mfrow = c(1, 3))\nhist(rnorm(1e4, 0, sqrt(tau2s[1])), xlim = c(-2, 2), xlab = latex2exp::TeX(\"$y_i$\"), main = tau2s_t[1], probability = TRUE, ylim = c(0, 4.5), col = \"dodgerblue\")\nhist(rnorm(1e4, 0, sqrt(tau2s[2])), xlim = c(-2, 2), xlab = latex2exp::TeX(\"$y_i$\"), main = tau2s_t[2], probability = TRUE, ylim = c(0, 4.5), col = \"dodgerblue\")\n#hist(rnorm(1e4, 0, sqrt(tau2s[3])), xlim = c(-2, 2), xlab = latex2exp::TeX(\"$y_i$\"), main = tau2s_t[3], probability = TRUE, ylim = c(0, 5))\nhist(rnorm(1e4, 0, sqrt(tau2s[4])), xlim = c(-2, 2), xlab = latex2exp::TeX(\"$y_i$\"), main = tau2s_t[4], probability = TRUE, ylim = c(0, 4.5), col = \"dodgerblue\")\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Intepreting $\\tau^2$\n\nAs in the previus plot we can assume $n = \\infty$ and generate true effects from @eq-re-mod2. In this way we understand the impact of assuming (or estimating) a certain $\\tau^2$.\n\nFor example, a $\\tau = 0.2$ and a $\\mu_{\\theta} = 0.5$, 50% of the true effects ranged between:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- 0.5\nyis <- D + rnorm(1e5, 0, 0.2)\nquantile(yis, c(0.75, 0.25))\n#>       75%       25% \n#> 0.6334614 0.3648225\n```\n:::\n\n\n\n\n\n## The $Q$ Statistics^[See @Harrer2021-go (Chapter 5) and @Hedges2019-ry for an overview about the Q statistics]\n\nThe Q statistics is used to make inference on the heterogeneity. Can be considered as a weighted sum of squares:\n\n$$\nQ = \\sum^k_{i = 1}w_i(y_i - \\hat \\mu)^2\n$$\n\nWhere $\\hat \\mu$ is EE estimation (regardless if $\\tau^2 \\neq 0$) and $w_i$ are the inverse-variance weights. Note that in the case of $w_1 = w_2 ... = w_i$, Q is just a standard sum of squares (or deviance).\n\n## The $Q$ Statistics\n\n- Given that we are summing up squared distances, they should be approximately $\\chi^2$ with $df = k - 1$. In case of no heterogeneity ($\\tau^2 = 0$) the observed variability is only caused by sampling error and the expectd value of the $\\chi^2$ is just the degrees of freedom ($df = k - 1$).\n- In case of $\\tau^2 \\neq 0$, the expected value is $k - 1 + \\lambda$ where $\\lambda$ is a non-centrality parameter.\n- In other terms, if the expected value of $Q$ exceed the expected value assuming no heterogeneity, we have evidence that $\\tau^2 \\neq 0$.\n\n## The $Q$ Statistics\n\nLet's try a more practical approach. We simulate a lot of meta-analysis with and without heterogeneity and we check the Q statistics.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nget_Q <- function(yi, vi){\n  wi <- 1/vi\n  theta_ee <- weighted.mean(yi, wi)\n  sum(wi*(yi - theta_ee)^2)\n}\n\nk <- 30\nn <- 30\ntau2 <- 0.1\nnsim <- 1e4\n\nQs_tau2_0 <- rep(0, nsim)\nQs_tau2 <- rep(0, nsim)\nres2_tau2_0 <- vector(\"list\", nsim)\nres2_tau2 <- vector(\"list\", nsim)\n\nfor(i in 1:nsim){\n  dat_tau2_0 <- sim_studies(k = 30, es = 0.5, tau2 = 0, n1 = n)\n  dat_tau2 <- sim_studies(k = 30, es = 0.5, tau2 = tau2, n1 = n)\n  \n  theta_ee_tau2_0 <- weighted.mean(dat_tau2_0$yi, 1/dat_tau2_0$vi)\n  theta_ee <- weighted.mean(dat_tau2$yi, 1/dat_tau2$vi)\n  \n  res2_tau2_0[[i]] <- dat_tau2_0$yi - theta_ee_tau2_0\n  res2_tau2[[i]] <- dat_tau2$yi - theta_ee\n  \n  Qs_tau2_0[i] <- get_Q(dat_tau2_0$yi, dat_tau2_0$vi)\n  Qs_tau2[i] <- get_Q(dat_tau2$yi, dat_tau2$vi)\n}\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## The $Q$ Statistics\n\nLet's try a more practical approach. We simulate a lot of meta-analysis with and without heterogeneity and we check the Q statistics.\n\n. . .\n\n- clearly, in the presence of heterogeneity, the expected value of the Q statistics is higher (due to $\\lambda \\neq 0$) and also residuals are larger (the $\\chi^2$ is just a sum of squared weighted residuals)\n\n. . .\n\n- we can calculate a p-value for deviation from the $\\tau^2 = 0$ case as evidence agaist the absence of heterogeneity\n\n## $I^2$ [@Higgins2002-fh]\n\nWe have two sources of variability in a random-effects meta-analysis, the sampling variability $\\sigma_i^2$ and true heterogeneity $\\tau^2$. We can use the $I^2$ to express the interplay between the two.\n$$\nI^2 = 100\\% \\times \\frac{\\hat{\\tau}^2}{\\hat{\\tau}^2 + \\tilde{v}}\n$${#eq-i2}\n\n$$\n\\tilde{v} = \\frac{(k-1) \\sum w_i}{(\\sum w_i)^2 - \\sum w_i^2},\n$$\n\nWhere $\\tilde{v}$ is the typical sampling variability. $I^2$ is intepreted as the proportion of total variability due to real heterogeneity (i.e., $\\tau^2$)\n\n## $I^2$ [@Higgins2002-fh]^[see [https://www.meta-analysis-workshops.com/download/common-mistakes1.pdf](https://www.meta-analysis-workshops.com/download/common-mistakes1.pdf)]\n\nNote that we can have the same $I^2$ in two completely different meta-analysis. An high $I^2$ does not represent high heterogeneity. Let's assume to have two meta-analysis with $k$ studies and small ($n = 30$) vs large ($n = 500$) sample sizes. \n\nLet's solve @eq-i2 for $\\tau^2$ (using `filor::tau2_from_I2()`) and we found that the same $I^2$ can be obtained with two completely different $\\tau^2$ values:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_1 <- 30\nvi_1 <- 1/n_1 + 1/n_1\ntau2_1 <- filor::tau2_from_I2(0.8, vi_1)\ntau2_1\n#> [1] 0.2666667\n\nn_2 <- 500\nvi_2 <- 1/n_2 + 1/n_2\ntau2_2 <- filor::tau2_from_I2(0.8, vi_2)\ntau2_2\n#> [1] 0.016\n```\n:::\n\n\n\n\n\n## $I^2$ [@Higgins2002-fh]\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_1 <- 30\nvi_1 <- 1/n_1 + 1/n_1\ntau2_1 <- filor::tau2_from_I2(0.8, vi_1)\ntau2_1\n#> [1] 0.2666667\n\nn_2 <- 500\nvi_2 <- 1/n_2 + 1/n_2\ntau2_2 <- filor::tau2_from_I2(0.8, vi_2)\ntau2_2\n#> [1] 0.016\n```\n:::\n\n\n\n\n\n. . .\n\nIn other terms, the $I^2$ can be considered a good index of heterogeneity only when the total variance ($\\tilde{v} + \\tau^2$) is similar.\n\n## What about $\\tilde{v}$?\n\n$\\tilde{v}$ is considered the \"typical\" within-study variability (see [https://www.metafor-project.org/doku.php/tips:i2_multilevel_multivariate](https://www.metafor-project.org/doku.php/tips:i2_multilevel_multivariate)). There are different estimators but @eq-tildev [@Higgins2002-fh] is the most common.\n\n$$\n\\tilde{v} = \\frac{(k-1) \\sum w_i}{(\\sum w_i)^2 - \\sum w_i^2}\n$$ {#eq-tildev}\n\n## What about $\\tilde{v}$?\n\nIn the hypothetical case where $\\sigma^2_1 = \\dots = \\sigma^2_k$, $\\tilde{v}$ is just $\\sigma^2$. This fact is commonly used to calculate the statistical power analytically [@Borenstein2009-mo, Chapter 29].\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvtilde <- function(wi){\n  k <- length(wi)\n  (k - 1) * sum(wi) / (sum(wi)^2 - sum(wi^2))\n}\n\nk <- 20\n\n# same vi\nvi <- rep((1/30 + 1/30), k)\nhead(vi)\n#> [1] 0.06666667 0.06666667 0.06666667 0.06666667 0.06666667 0.06666667\nvtilde(1/vi)\n#> [1] 0.06666667\n\n# heterogeneous vi\nn <- 10 + rpois(k, 30 - 10)\nvi <- sim_vi(k = k, n1 = n)\nvtilde(1/vi)\n#> [1] 0.06389075\n```\n:::\n\n\n\n\n\n## What about $\\tilde{v}$?\n\nUsing simulations we can see that $\\tilde{v}$ with heterogenenous variances (i.e., sample sizes in this case) can be approximated by the central tendency of the sample size distribution. Note that we are fixing $\\sigma^2 = 1$ thus we are not including uncertainty.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nk <- 100 # number of studies\nn <- 30 # sample size\n\nvti <- rep(NA, 1e5)\n\nfor(i in 1:1e5){\n  ni <- rpois(k, n)\n  vi <- 1/ni + 1/ni\n  vti[i] <- vtilde(1/vi)\n}\n\n# vtilde calculated from lambda\nvt <- 1/n + 1/n\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## $H^2$\n\nThe $H^2$ is an alternative index of heterogeneity. Is calculated as:\n\n$$\nH^2 = \\frac{Q}{k - 1}\n$$\n\nWe defined $Q$ as the weighted sum of squares representing the total variability. $k - 1$ is the expected value of the $\\chi^2$ statistics (i.e., sum of squares) when $\\tau^2 = 0$ (or $\\lambda = 0$). \n\nThus $H^2$ is the ratio between total heterogeneity and sampling variability. Higher $H^2$ is associated with higher heterogeneity **relative** to the sampling variability. $H^2$ is not a measure of absolute heterogeneity.\n\n## $H^2$\n\nWhen we are fitting a RE model, the $I^2$ and $H^2$ equations are slightly different [@Higgins2002-fh]. See also the `metafor` [source code](https://github.com/cran/metafor/blob/994d26a65455fac90760ad6a004ec1eaca5856b1/R/rma.uni.r#L2459C30-L2459C30).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 100\nmu <- 0.5\ntau2 <- 0.1\nn <- 30\n\ndat <- sim_studies(k = k, es = mu, tau2 = tau2, n1 = n)\nfit_re <- rma(yi, vi, data = dat, method = \"REML\")\nfit_ee <- rma(yi, vi, data = dat, method = \"EE\")\n\n# H2 with EE model\n\ntheta_ee <- fit_ee$b[[1]] # weighted.mean(dat$yi, 1/dat$vi)\nwi <- 1/dat$vi\nQ <- with(dat, sum((1/vi)*(yi - theta_ee)^2))\nc(Q, fit_ee$QE) # same\n#> [1] 350.1654 350.1654\n\nc(H2 = fit_ee$QE / (fit_ee$k - fit_ee$p), H2_model = fit_ee$H2) # same\n#>       H2 H2_model \n#> 3.537024 3.537024\n\n# H2 with RE model\n\nvt <- vtilde(1/dat$vi)\nc(H2 = fit_re$tau2 / vt + 1, H2_model = fit_re$H2) # same\n#>       H2 H2_model \n#> 3.495119 3.495119\n```\n:::\n\n\n\n\n\n## Confidence Intervals\n\nWhat is reported in the model summary as `ci.lb` and `ci.ub` refers to the 95% confidence interval representing the uncertainty in estimating the effect (or a meta-regression parameter).\n\nWithout looking at the equations, let's try to implement this idea using simulations.\n\n- choose $k$, $\\tau^2$ and $n$\n- simulate data (several times) accordingly and fit the RE model\n- extract the estimated effect size\n- compare the simulated sampling distribution with the analytical result\n\n## Confidence Intervals\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 30\nn <- 30\ntau2 <- 0.05\nmu <- 0.5\nnsim <- 5e3\n\n# true parameters (see Borenstein, 2009; Chapter 29)\nvt <- 1/n + 1/n\nvs <- (vt + tau2)/ k\nse <- sqrt(vs)\n\nmui <- rep(NA, nsim)\n\nfor(i in 1:nsim){\n  dat <- sim_studies(k = k, es = mu, tau2 = tau2, n1 = n)\n  fit <- rma(yi, vi, data = dat)\n  mui[i] <- coef(fit)[1]\n}\n\n# standard error\nc(simulated = sd(mui), analytical = fit$se)\n#>  simulated analytical \n#> 0.06322640 0.06508356\n\n# confidence interval\nrbind(\n  \"simulated\"  = quantile(mui, c(0.05, 0.975)),\n  \"analytical\" = c(\"2.5%\" = fit$ci.lb, \"97.5%\" = fit$ci.ub)\n)\n#>                   5%     97.5%\n#> simulated  0.3958958 0.6226868\n#> analytical 0.3721610 0.6272838\n```\n:::\n\n\n\n\n\n## Confidence Intervals\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(mui, breaks = 50, freq = FALSE, main = \"Sampling Distribution\", xlab = latex2exp::TeX(\"$\\\\mu_{\\\\theta}$\"))\ncurve(dnorm(x, mu, se), add = TRUE, col = \"firebrick\", lwd = 1.5)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Confidence Intervals\n\nNow the equation for the 95% confidence interval should be more clear. The standard error is a function of the within study sampling variances (depending mainly on $n$), $\\tau^2$ and $k$. As we increase $k$ the standard error tends towards zero. \n\n$$\nCI = \\hat \\mu_{\\theta} \\pm z SE_{\\mu_{\\theta}}\n$$\n\n$$\nSE_{\\mu_{\\theta}} = \\sqrt{\\frac{1}{\\sum^{k}_{i = 1}w^{\\star}_i}}\n$$\n\n$$\nw^{\\star}_i = \\frac{1}{\\sigma^2_i + \\tau^2}\n$$\n\n## Confidence Intervals\n\nWe can also see it analytically, there is a huge impact of $k$.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# true parameters (see Borenstein, 2009; Chapter 29)\nvt <- 1/n + 1/n\nvs <- (vt + tau2)/ k\nse <- sqrt(vs)\n\nk <- c(10, 50, 100, 500, 1000, 5000)\nn <- c(10, 50, 100, 500, 1000, 5000)\ntau2 <- c(0, 0.05, 0.1, 0.2)\n\ndd <- expand.grid(k = k, n = n, tau2 = tau2)\n\ndd$vt <- with(dd, 1/n + 1/n)\ndd$vs <- with(dd, (vt + tau2)/ k)\ndd$se <- sqrt(dd$vs)\n\ndd$k <- as_tex_label(dd$k, \"$k = %s$\")\n\nggplot(dd, aes(x = n, y = se, color = factor(tau2))) +\n  geom_line() +\n  facet_wrap(~k, labeller = label_parsed) +\n  labs(color = latex2exp::TeX(\"\\\\tau^2\")) +\n  xlab(\"Sample Size (n)\") +\n  ylab(latex2exp::TeX(\"$SE_{\\\\mu_{\\\\theta}}$\"))\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-58-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Prediction intervals (PI)\n\nWe could say that the CI is not completely taking into account the between-study heterogeneity ($\\tau^2$). After a meta-analysis we would like to know how confident we are in the parameters estimation BUT also **what would be the expected effect running a new experiment tomorrow?**.\n\nThe **prediction interval** [@IntHout2016-sz; @Riley2011-hp] is exactly the range of effects that I expect in predicting a new study.\n\n## PI for a sample mean\n\nTo understand the concept, let's assume to have a sample $X$ of size $n$ and we estimate the mean $\\overline X$. The PI is calculated as^[Notice that the equation, in particular the usage of $t$ vs $z$ depends on assuming $s_x$ to be known or estimated. See [https://online.stat.psu.edu/stat501/lesson/3/3.3](https://online.stat.psu.edu/stat501/lesson/3/3.3), [https://en.wikipedia.org/wiki/Prediction_interval](https://en.wikipedia.org/wiki/Prediction_interval) and [https://www.bryanshalloway.com/2021/03/18/intuition-on-uncertainty-of-predictions-introduction-to-prediction-intervals/](https://www.bryanshalloway.com/2021/03/18/intuition-on-uncertainty-of-predictions-introduction-to-prediction-intervals/)]:\n\n$$\nPI = \\overline X \\pm t_{\\alpha/2} s_x \\sqrt{1 + \\frac{1}{n}}\n$$\n\nWhere $s$ is the sample standard deviation. Basically we are combining the uncertainty in estimating $\\overline X$ (i.e, $\\frac{s_x}{n}$) with the standard deviation of the data $s_x$. Compare it with the confidence interval containing only $\\frac{s_x}{n}$.\n\n## PI in meta-analysis\n\nFor meta-analysis the equation^[When a $t$ distribution is assumed, the quantiles are calculated using $k - 2$ degrees of freedom] is conceptually similar but with different quantities.\n\n$$\nPI = \\hat \\mu_{\\theta} \\pm z \\sqrt{\\tau^2 + SE_{\\mu_{\\theta}}}\n$$\n\nBasically we are combining all the sources of uncertainty. As long as $\\tau^2 \\neq 0$ the PI is greater than the CI (in the EE model they are the same). Thus even with very precise $\\mu_{\\theta}$ estimation, large $\\tau^2$ leads to uncertain predictions.\n\n## PI in meta-analysis\n\nIn R the PI can be calculated using `predict()`. By default the model assume a standard normal distribution thus using $z$ scores. To use the @Riley2011-hp approach ($t$ distribution) the model need to be fitted using `test = \"t\"`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 100\ndat <- sim_studies(k = k, es = 0.5, tau2 = 0.1, n1 = 30)\nfit_z <- rma(yi, vi, data = dat, test = \"z\") # test = \"z\" is the default\npredict(fit_z) # notice pi.ub/pi.lb vs ci.ub/ci.lb\n#> \n#>    pred     se  ci.lb  ci.ub   pi.lb  pi.ub \n#>  0.4423 0.0424 0.3592 0.5254 -0.2299 1.1145\n# manually\nfit_z$b[[1]] + qnorm(c(0.025, 0.975)) * sqrt(fit_z$se^2 + fit_z$tau2)\n#> [1] -0.229882  1.114516\n\nfit_t <- rma(yi, vi, data = dat, test = \"t\")\npredict(fit_t) # notice pi.ub/pi.lb vs ci.ub/ci.lb\n#> \n#>    pred     se  ci.lb  ci.ub   pi.lb  pi.ub \n#>  0.4423 0.0424 0.3582 0.5265 -0.2382 1.1228\n# manually\nfit_z$b[[1]] + qt(c(0.025, 0.975), k - 2) * sqrt(fit_t$se^2 + fit_t$tau2)\n#> [1] -0.2382858  1.1229198\n```\n:::\n\n\n\n\n\n# Meta-analysis as (weighted) linear regression {.section}\n\n## MA as (weighted) linear regression\n\nBoth the EE and RE model can be seen as standard (weighted) linear regression models. Precisely, there is a difference in fitting a meta-analysis using `lm` or `lme4::lmer()` and `rma` (see [https://www.metafor-project.org/doku.php/tips:rma_vs_lm_lme_lmer](https://www.metafor-project.org/doku.php/tips:rma_vs_lm_lme_lmer)).\n\n. . .\n\nBeyond these differences a general the EE and RE models are intercept-only linear regressions.\n\n$$\n\\boldsymbol{Y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\epsilon}\n$$\n\nThe EE model:\n\n$$\ny_i = \\beta_0 + \\epsilon_i \n$$\n\nThe RE model:\n\n$$\ny_i = \\beta_0 + \\beta_{0_i} + \\epsilon_i \n$$\n\n## MA as (weighted) linear regression\n\nIn the EE model $\\beta_0$ is $\\theta$ and $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2_i)$\n\n$$\ny_i = \\beta_0 + \\epsilon_i \n$$\n\nIn the RE model $\\beta_0$ is $\\mu_{\\theta}$ and $\\beta_{0_i}$ are the $\\delta_i$.\n\n## Explaining $\\tau^2$\n\nSo far we simply assumed $\\tau^2 = 0$ (for the EE model) or estimated it using the RE model.\n\n. . .\n\nWe can extend the intercept-only meta-analysis by including study-level predictors (as in standard linear regression) to explain the estimated true heterogeneity.\n\n## Explaining $\\tau^2$\n\nLet's make an example where we simulate a meta-analysis with $k = 100$ studies. Beyond the effect size, we extracted an experimental condition where 50 studies where lab-based experiments $x_{lab}$ and 50 studies where online experiments.\n\nWe assume that there could be a **lab effect** thus we included a predictor in the model.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 100\nn <- 10 + rpois(k, 40 - 10)\nexp <- rep(c(\"lab\", \"online\"), each = k/2)\n```\n:::\n\n\n\n\n\n## Explaining $\\tau^2$\n\nNow the model have a predictor $x$ (the type of experiment) and two parameters $\\beta_0$ and $\\beta_1$. Depending on the contrast coding (default to `contr.treatment()` in R) the $\\beta_0$ is different. Coding `exp` as 0 for lab-based experiments and 1 for online experiments:\n\n$$\ny_i = \\beta_0 + \\beta_1X_{1_i} + \\epsilon_i\n$$\n\n$$\ny_{\\text{lab}_i} = \\beta_0 + \\epsilon_i\n$$\n\n$$\ny_{\\text{online}_i} = \\beta_0 + \\beta_1 + \\epsilon_i\n$$\n\n## Explaining $\\tau^2$\n\nWhat is missing is the random-effect. Basically we still have $\\tau^2$ determining the $\\delta_i \\sim \\mathcal{N}(0, \\tau^2)$ but now is the residual $\\tau^2_r$. The heterogeneity after including the predictor.\n\n$$\ny_i = \\beta_0 + \\beta_{0_i} + \\beta_1X_{1_i} + \\epsilon_i\n$$ {#eq-metareg-cat}\n\n$$\n\\beta_{0_i} \\sim \\mathcal{N}(0, \\tau^2_r)\n$$\n\nClearly the difference between $\\tau^2$ (the total heterogeneity) and $\\tau^2_r$ (residual heterogeneity) is an index of the impact of $X$.\n\n## Simulating the $X$ effect\n\nTo simulate a meta-regression we just need to choose the parameters values ($\\beta_0$ and $\\beta_1$) and implement @eq-metareg-cat. Using treatment coding, $\\beta_0$ is the effect size when $X = 0$ (i.e., lab-based experiments) and $\\beta_1$ is the difference between lab and online experiments.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb0 <- 0.3 # lab-based effect size\nb1 <- 0.5 # online - lab-based --> online = b0 + b1\nexp_dummy <- ifelse(exp == \"lab\", 0, 1) # dummy version\nes <- b0 + b1 * exp_dummy\nht(data.frame(exp, exp_dummy, es))\n#>        exp exp_dummy  es\n#> 1      lab         0 0.3\n#> 2      lab         0 0.3\n#> 3      lab         0 0.3\n#> 4      lab         0 0.3\n#> 5      lab         0 0.3\n#> 95  online         1 0.8\n#> 96  online         1 0.8\n#> 97  online         1 0.8\n#> 98  online         1 0.8\n#> 99  online         1 0.8\n#> 100 online         1 0.8\n```\n:::\n\n\n\n\n\n## Simulating the $X$ effects\n\nNow we can use the `sim_studies()` function as usual. The difference is that `es` is no longer a single value but a vector (with different values according to the $X$ level) and `tau2` is $\\tau^2_r$ (this the leftover heterogeneity after including the $X$ effect)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntau2r <- 0.05 # residual heterogeneity\ndat <- sim_studies(k = k, es = es, tau2 = tau2r, n1 = n, add = list(exp = exp))\nht(dat)\n#> \n#>      id      yi     vi n1 n2    exp \n#> 1     1  0.3868 0.0634 40 40    lab \n#> 2     2  0.7162 0.0620 40 40    lab \n#> 3     3 -0.0864 0.0601 36 36    lab \n#> 4     4  0.0536 0.0516 40 40    lab \n#> 5     5  0.2547 0.0573 34 34    lab \n#> 95   95  1.4493 0.0530 31 31 online \n#> 96   96  0.9304 0.0527 41 41 online \n#> 97   97  1.0688 0.0420 47 47 online \n#> 98   98  0.6288 0.0511 38 38 online \n#> 99   99  1.2018 0.0462 41 41 online \n#> 100 100  0.6452 0.0702 29 29 online\n```\n:::\n\n\n\n\n\n## Fitting a meta-regression Model\n\nTo fit a meta-regression we still use the `metafor::rma()` function, adding the `mods = ~` parameter with the model formula (same as the right-hand side of a `y ~ x` call in `lm`). The name of the predictor in the formula need to match a column of the `data = ` dataframe.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- rma(yi, vi, mods = ~ exp, data = dat, method = \"REML\")\nsummary(fit)\n#> \n#> Mixed-Effects Model (k = 100; tau^2 estimator: REML)\n#> \n#>   logLik  deviance       AIC       BIC      AICc   \n#> -30.6576   61.3152   67.3152   75.0701   67.5706   \n#> \n#> tau^2 (estimated amount of residual heterogeneity):     0.0610 (SE = 0.0158)\n#> tau (square root of estimated tau^2 value):             0.2471\n#> I^2 (residual heterogeneity / unaccounted variability): 55.34%\n#> H^2 (unaccounted variability / sampling variability):   2.24\n#> R^2 (amount of heterogeneity accounted for):            48.11%\n#> \n#> Test for Residual Heterogeneity:\n#> QE(df = 98) = 220.5886, p-val < .0001\n#> \n#> Test of Moderators (coefficient 2):\n#> QM(df = 1) = 53.2544, p-val < .0001\n#> \n#> Model Results:\n#> \n#>            estimate      se    zval    pval   ci.lb   ci.ub      \n#> intrcpt      0.3301  0.0472  6.9990  <.0001  0.2377  0.4226  *** \n#> exponline    0.4871  0.0667  7.2976  <.0001  0.3563  0.6179  *** \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\n## Intepreting a meta-regression Model\n\nThe output is similar to the RE model with few additions:\n\n- Everything related to the heterogeneity ($H^2$, $I^2$, $Q$, etc.) is now about **residual heterogeneity**\n- There is the (pseudo) $R^2$\n- There is an overall test for the moderators $Q_M$\n- There is a section (similar to standard regression models) with the estimated parameters, standard error and Wald test\n\n## Model parameters\n\n`intrcpt` and `exponline` are the estimates of $\\beta_0$ and $\\beta_1$. The interpretation depends on the scale of the effect size and the contrast coding.\n\nWe can plot the model results using the `metafor::regplot()`^[The functions is made for numerical variables thus is less appropriate for categorical variables].\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregplot(fit)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-64-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Omnibus Moderator Test\n\nThe `Test of Moderators` section report the so-called omnibus test for model coeffiecients. Is a simultaneous test for 1 or more coefficients where $H_0: \\beta_j = 0$.\n\nIn this case, **coefficient 2** means that we are testing only the 2nd coefficient $\\beta_1$. By default, the intercept is ignored. In fact, the `exponline` line and the omnibus test are the same (the $\\chi^2$ is just the $z^2$)\n\n\n\n\n\n::: {.cell}\n\n```\n#> Test of Moderators (coefficient 2):\n#> QM(df = 1) = 53.2544, p-val < .0001\n#>            estimate      se    zval    pval   ci.lb   ci.ub      \n#> intrcpt      0.3301  0.0472  6.9990  <.0001  0.2377  0.4226  *** \n#> exponline    0.4871  0.0667  7.2976  <.0001  0.3563  0.6179  ***\n```\n:::\n\n\n\n\n\n## General Linear Hypotheses Testing (GLHT)\n\nWe can also test any combination of parameters. For example we could test if lab-based experiments and online experiments are both different from 0. This is the same as fitting a model without the intercept^[see [https://www.metafor-project.org/doku.php/tips:models_with_or_without_intercept](https://www.metafor-project.org/doku.php/tips:models_with_or_without_intercept) on removing the intercept] thus estimating the cell means [see @Schad2020-ht].\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# now we are testing two coefficients\nfit_no_int <- rma(yi, vi, mods = ~ 0 + exp, data = dat)\n```\n:::\n\n\n\n\n\n## General Linear Hypotheses Testing (GLHT)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_no_int\n#> \n#> Mixed-Effects Model (k = 100; tau^2 estimator: REML)\n#> \n#> tau^2 (estimated amount of residual heterogeneity):     0.0610 (SE = 0.0158)\n#> tau (square root of estimated tau^2 value):             0.2471\n#> I^2 (residual heterogeneity / unaccounted variability): 55.34%\n#> H^2 (unaccounted variability / sampling variability):   2.24\n#> \n#> Test for Residual Heterogeneity:\n#> QE(df = 98) = 220.5886, p-val < .0001\n#> \n#> Test of Moderators (coefficients 1:2):\n#> QM(df = 2) = 348.4548, p-val < .0001\n#> \n#> Model Results:\n#> \n#>            estimate      se     zval    pval   ci.lb   ci.ub      \n#> explab       0.3301  0.0472   6.9990  <.0001  0.2377  0.4226  *** \n#> exponline    0.8172  0.0472  17.3052  <.0001  0.7247  0.9098  *** \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\n## General Linear Hypotheses Testing (GLHT)\n\nA more elegant way is by using the GLHT framework. Basically we provide a contrast matrix expressing linear combinations of model parameters to be tested. In our case $\\text{lab} = \\beta_0 = 0$ and $\\text{online} = \\beta_0 + \\beta_1 = 0$.\n\nPractically, the matrix formulation is the following:\n\n$$\n\\begin{pmatrix}  \n1 & 0 \\\\\n1 & 1\n\\end{pmatrix}\n\\begin{pmatrix}  \n\\beta_0\\\\\n\\beta_1\n\\end{pmatrix}\n=\n\\begin{pmatrix}  \n0\\\\\n0\n\\end{pmatrix}\n$$\n\nIn R:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nC <- rbind(c(1, 0), c(1, 1))\nB <- coef(fit)\nC %*% B # same as coef(fit)[1] and coef(fit)[1] +  coef(fit)[2]\n#>           [,1]\n#> [1,] 0.3301324\n#> [2,] 0.8172112\n```\n:::\n\n\n\n\n\n## General Linear Hypotheses Testing (GLHT)\n\nWe can use the `anova()` function providing the model and the hypothesis matrix.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(fit) # the default\n#> \n#> Test of Moderators (coefficient 2):\n#> QM(df = 1) = 53.2544, p-val < .0001\nanova(fit, X = C)\n#> \n#> Hypotheses:                           \n#> 1:             intrcpt = 0 \n#> 2: intrcpt + exponline = 0 \n#> \n#> Results:\n#>    estimate     se    zval   pval \n#> 1:   0.3301 0.0472  6.9990 <.0001 \n#> 2:   0.8172 0.0472 17.3052 <.0001 \n#> \n#> Omnibus Test of Hypotheses:\n#> QM(df = 2) = 348.4548, p-val < .0001\n```\n:::\n\n\n\n\n\nNotice that is the same as the model without the intercept.\n\n## Likelihood Ratio Test (LRT)\n\nAs in standard regression modelling, we can also compare models using LRT. The `anova()` function will compute the LRT when two (nested) models are provided. In this case we compared a null (intercept-only) model with the model including the predictor.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the null model\nfit0 <- rma(yi, vi, data = dat, method = \"REML\")\nanova(fit0, fit, refit = TRUE) # refit = TRUE because LRT with REML is not meaningful, using ML instead\n#> \n#>         df      AIC      BIC     AICc   logLik     LRT   pval       QE  tau^2 \n#> Full     3  66.5817  74.3972  66.8317 -30.2908                220.5886 0.0589 \n#> Reduced  2 108.5228 113.7331 108.6465 -52.2614 43.9411 <.0001 336.6655 0.1160 \n#>              R^2 \n#> Full             \n#> Reduced 49.2018%\n```\n:::\n\n\n\n\n\n## $R^2$\n\nThe $R^2$ value reported in the model output is not calculated as in standard regression analysis.\n\n$$\nR^2 = 1 - \\frac{\\tau^2_r}{\\tau^2}\n$$\n\nBasically is the percentage of heterogeneity reduction from the intercept-only model to the model including predictors.\n\nIn R:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(1 - fit$tau2/fit0$tau2)*100\n#> [1] 48.1096\nfit$R2\n#> [1] 48.1096\n```\n:::\n\n\n\n\n\n## $R^2$\n\nDespite useful, the $R^2$ has some limitations:\n\n- @Lopez-Lopez2014-it showed that precise estimations require a large number of studies $k$ \n- Sometimes could results in negative values (usually truncated to zero)\n- Depends on the $\\tau^2$ estimator\n\nMore about $R^2$ and limitations can be found:\n\n- [https://www.metafor-project.org/doku.php/faq#for_mixed-effects_models_how_i](https://www.metafor-project.org/doku.php/faq#for_mixed-effects_models_how_i)\n- [https://www.metafor-project.org/doku.php/tips:ci_for_r2](https://www.metafor-project.org/doku.php/tips:ci_for_r2)\n\n## Numerical predictor\n\nThe same logic of simulating a meta-regression can be applied to numerical predictors. We still have $\\beta_0$ and $\\beta_1$ but $X$ has more levels. Let's simulate an impact of the average participants' age on the effect size.\n\n- $\\beta_0$ is the effect size when **age** is zero\n- $\\beta_1$ is the expected increase in the effect size for a unit increase in `age`\n\nHow we can choose plausible values for the parameters and parametrize the model correctly?\n\n## Parametrize $\\beta_0$\n\nThe intepretation (and the inference) of $\\beta_0$ is strongly dependent on the type of numerical predictor. An age of zero is (probably) empirically meaningless thus the  $\\beta_0$ is somehow not useful.\n\nWe can for example mean-center (or other type of centering procedure) moving the zero on a meaningful value.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- 10:50 # the raw vector\nage0 <- age - mean(age) # centering on the mean\nage20 <- age - min(age) # centering on the minimum\n\nht(data.frame(age, age0, age20))\n#>    age age0 age20\n#> 1   10  -20     0\n#> 2   11  -19     1\n#> 3   12  -18     2\n#> 4   13  -17     3\n#> 5   14  -16     4\n#> 36  45   15    35\n#> 37  46   16    36\n#> 38  47   17    37\n#> 39  48   18    38\n#> 40  49   19    39\n#> 41  50   20    40\n```\n:::\n\n\n\n\n\n## Parametrize $\\beta_0$\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-73-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Parametrize $\\beta_0$\n\nUsing different parametrizations will only affect the estimation (and the interpretation) of $\\beta_0$. Other parameters and indexes will be the same.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 100\nb0 <- 0.2 # effect size when age 0\nb1 <- 0.05 # slope (random for now)\nage <- round(runif(k, 20, 50)) # sampling from uniform distribution\ntau2r <- 0.05\nn <- 10 + rpois(k, 30 - 10)\n\nes <- b0 + b1 * age # raw\n\nage0 <- age - mean(age)\nage20 <- age - 20\n\ndat <- sim_studies(k = k, es = es, tau2 = tau2r, n1 = n, add = list(age = age, age0 = age0, age20 = age20))\n\nfit <- rma(yi, vi, mods = ~ age, data = dat)\nfit0 <- rma(yi, vi, mods = ~ age0, data = dat)\nfit20 <- rma(yi, vi, mods = ~ age20, data = dat)\n\n# showing the intercept\ncompare_rma(fit, fit0, fit20, extra_params = \"R2\") |> \n  round(3)\n#> fit: rma(yi = yi, vi = vi, mods = ~age, data = dat)\n#> fit0: rma(yi = yi, vi = vi, mods = ~age0, data = dat)\n#> fit20: rma(yi = yi, vi = vi, mods = ~age20, data = dat)\n#>                fit   fit0  fit20\n#> b (intrcpt)  0.371  2.026  1.290\n#> se           0.153  0.036  0.076\n#> zval         2.427 56.591 17.076\n#> pval         0.015  0.000  0.000\n#> ci.lb        0.071  1.956  1.142\n#> ci.ub        0.671  2.096  1.438\n#> R2          71.443 71.443 71.443\n#> I2          49.486 49.486 49.486\n#> tau2         0.063  0.063  0.063\n\n  # showing the intercept\ncompare_rma(fit, fit0, fit20, b = \"age\", extra_params = \"R2\") |> \n  round(3)\n#> fit: rma(yi = yi, vi = vi, mods = ~age, data = dat)\n#> fit0: rma(yi = yi, vi = vi, mods = ~age0, data = dat)\n#> fit20: rma(yi = yi, vi = vi, mods = ~age20, data = dat)\n#>            fit   fit0  fit20\n#> b (age)  0.046  0.046  0.046\n#> se       0.004  0.004  0.004\n#> zval    11.152 11.152 11.152\n#> pval     0.000  0.000  0.000\n#> ci.lb    0.038  0.038  0.038\n#> ci.ub    0.054  0.054  0.054\n#> R2      71.443 71.443 71.443\n#> I2      49.486 49.486 49.486\n#> tau2     0.063  0.063  0.063\n```\n:::\n\n\n\n\n\n## Choosing $\\beta_1$\n\nThe core of the model is $\\beta_1$ that is the **age** effect. Compared to the categorical case where $\\beta_1$ is just the standardized difference between two conditions, with numerical $X$ choosing a meaningful $\\beta_1$ is more challenging.\n\nTwo (maybe more) strategies:\n\n- simulating a lot of effects sizes fixing $beta_0$ and $\\beta_1$ and see the expected range of $y_i$\n- fixing a certain $R^2$ and choose the $\\beta_1$ producing that $R^2$\n- ...\n\n## $\\beta_1$ by simulations\n\nA strategy could be to simulate from the generative model a large number of studies and see the expected range of effect size [@Gelman2020-tg, Chapter 5 and p. 97]. A large number of unplausible values suggest that the chosen $\\beta_1$ is probably not appropriate.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 1e3\nn <- 30\ntau2 <- 0\nx <- runif(k, 20, 50) # age\nb0 <- 0.1\nb1 <- c(0.001, 0.05, 0.2)\nesl <- lapply(b1, function(b) b0 + b*x)\ndatl <- lapply(esl, function(es) sim_studies(k = k, es = es, tau2 = tau2, n1 = n, add = list(x = x)))\nnames(datl) <- b1\ndat <- dplyr::bind_rows(datl, .id = \"b1\")\nht(dat)\n#> \n#>         b1   id      yi     vi n1 n2        x \n#> 1    0.001    1 -0.0234 0.0649 30 30 36.66325 \n#> 2    0.001    2 -0.2818 0.0528 30 30 37.59875 \n#> 3    0.001    3 -0.1208 0.0969 30 30 37.89483 \n#> 4    0.001    4  0.3004 0.0509 30 30 24.06663 \n#> 5    0.001    5 -0.1076 0.0560 30 30 22.65956 \n#> 2995   0.2  995  8.9069 0.0616 30 30 43.62926 \n#> 2996   0.2  996  4.6568 0.0618 30 30 21.95671 \n#> 2997   0.2  997  5.9464 0.0631 30 30 30.73639 \n#> 2998   0.2  998  6.6676 0.0712 30 30 31.20466 \n#> 2999   0.2  999  9.8789 0.0994 30 30 48.16696 \n#> 3000   0.2 1000  5.7442 0.0702 30 30 28.71515\n```\n:::\n\n\n\n\n\n## $\\beta_1$ by simulations\n\nClearly given the limited range of the $x$ variable (`age`) some $\\beta_1$ values are implausible leading to effect sizes that are out of a meaningful empirical range.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndat$b1 <- factor(dat$b1, labels = latex2exp::TeX(sprintf(\"$\\\\beta_1 = %s$\", unique(dat$b1))))\ndat |> \n  ggplot(aes(x = x, y = yi)) +\n  geom_point() +\n  facet_wrap(~b1, scales = \"free_y\", labeller = label_parsed) +\n  xlab(\"Age\") +\n  ylab(latex2exp::TeX(\"$y_i$\"))\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-76-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Fixing $R^2$\n\nWe can use the approach by @Lopez-Lopez2014-it where predictors $x$ are sampled from a standard normal distribution (or standardized). $\\beta_1$ is calculated as $\\beta_1 = \\sqrt{\\tau^2 R^2}$ and the residual heterogeneity as $\\tau^2_r = \\tau^2 - \\beta^2_1$.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 100\nn <- 30\ntau2 <- 0.3\nR2 <- 0.4\nb0 <- 0.1\nb1_2 <- tau2 * R2\nb1 <- sqrt(b1_2)\ntau2r <- tau2 - b1_2\n```\n:::\n\n\n\n\n\n## Fixing $R^2$\n\nWe can check the simulation approach:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 1e3\n1 - tau2r/tau2\n#> [1] 0.4\nx <- rnorm(k)\nes <- b0 + b1 * x\ndat <- sim_studies(k, es, tau2r, n1 = 1e3, add = list(x = x))\nfit <- rma(yi, vi, data = dat, mods = ~x)\nsummary(fit)\n#> \n#> Mixed-Effects Model (k = 1000; tau^2 estimator: REML)\n#> \n#>    logLik   deviance        AIC        BIC       AICc   \n#> -562.0096  1124.0193  1130.0193  1144.7365  1130.0434   \n#> \n#> tau^2 (estimated amount of residual heterogeneity):     0.1786 (SE = 0.0081)\n#> tau (square root of estimated tau^2 value):             0.4226\n#> I^2 (residual heterogeneity / unaccounted variability): 98.89%\n#> H^2 (unaccounted variability / sampling variability):   90.40\n#> R^2 (amount of heterogeneity accounted for):            43.09%\n#> \n#> Test for Residual Heterogeneity:\n#> QE(df = 998) = 90168.4129, p-val < .0001\n#> \n#> Test of Moderators (coefficient 2):\n#> QM(df = 1) = 749.0935, p-val < .0001\n#> \n#> Model Results:\n#> \n#>          estimate      se     zval    pval   ci.lb   ci.ub      \n#> intrcpt    0.0830  0.0134   6.1759  <.0001  0.0567  0.1094  *** \n#> x          0.3628  0.0133  27.3696  <.0001  0.3368  0.3888  *** \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\n## $R^2$ using simulations\n\nThe results from @Lopez-Lopez2014-it (and also our previous simulation) suggested that we need a large number of studies for precise $R^2$ estimations. Let's check using simulations the sampling distribution of $R^2$ using a plausible meta-analysis scenario.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 40 # number of studies\nn <- 10 + rpois(k, 40 - 10) # sample size\ntau2 <- 0.05 # tau ~ 0.22\nR2 <- 0.3\nb0 <- 0.1\nb1_2 <- tau2 * R2\nb1 <- sqrt(b1_2)\ntau2r <- tau2 - b1_2\nnsim <- 1e3\n\nR2i <- rep(NA, nsim)\n\nfor(i in 1:nsim){\n  x <- rnorm(k)\n  dat <- sim_studies(k = k, es = b0 + b1*x, tau2 = tau2r, n1 = n, add = list(x))\n  fit <- rma(yi, vi, data = dat, mods = ~x)\n  R2i[i] <- fit$R2\n}\n```\n:::\n\n\n\n\n\n## $R^2$ using simulations\n\nWe estimated the true $R^2$ correctly but there is a lot of uncertainty with a plausible meta-analysis scenario. There are a lot of meta-analysis also with lower $k$ worsening the results.\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-80-1.png){width=672}\n:::\n:::\n\n\n\n\n\n# Publication Bias (PB) {.section}\n\n# What do you think about PB? What do you know? Causes? Remedies?  {.question .smaller}\n\n## Publication Bias (PB)\n\nThe PB is a very critical **most problematic aspects** of meta-analysis. Essentially **the probability of publishing a paper** (~and thus including into the meta-analysis) [is not the same regardless of the result]{.imp}.\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-81-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Publication Bias Disclaimer!\n\n**We cannot (completely) solve the PB using statistical tools**. The PB is a problem related to the publishing process and publishing incentives\n\n. . .\n\n- **pre-registrations**, **multi-lab studies**, etc. can (almost) completely solve the problem filling the literature with unbiased studies\n\n. . .\n\n- there are **statistical tools to detect, estimate and correct** for the publication bias. As every statistical method, they are influenced by statistical assumptions, number of studies and sample size, heterogeneity, etc.\n\n## Publication Bias (PB) - The Big Picture^[Thanks to the Wolfgang Viechtbauer's course [https://www.wvbauer.com/doku.php/course_ma](https://www.wvbauer.com/doku.php/course_ma)]\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](img/big-picture.svg)\n:::\n:::\n\n\n\n\n\n## PB under an EE model\n\nThe easiest way to understand the PB is by simulating what happen without the PB. Let's simulate a lot of studies (under a EE model) keeping all the results without selection (the ideal world).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2023)\nk <- 1e3\nn <- round(runif(k, 10, 100))\ntheta <- 0.3\ndat <- sim_studies(k = k, es = theta, tau2 = 0, n1 = n)\ndat <- summary(dat)\n# compute 1 tail pvalue\ndat$pval1 <- 1 - pnorm(dat$zi)\nht(dat)\n#> \n#>        id      yi     vi n1 n2    sei      zi   pval   ci.lb  ci.ub       pval1 \n#> 1       1  0.3483 0.0406 52 52 0.2015  1.7287 0.0839 -0.0466 0.7431 0.041927744 \n#> 2       2  0.3762 0.0605 40 40 0.2460  1.5291 0.1262 -0.1060 0.8585 0.063119366 \n#> 3       3  0.0634 0.0911 25 25 0.3018  0.2101 0.8336 -0.5281 0.6549 0.416800171 \n#> 4       4  0.4101 0.0487 46 46 0.2206  1.8588 0.0631 -0.0223 0.8426 0.031530757 \n#> 5       5 -0.0476 0.1160 13 13 0.3405 -0.1398 0.8888 -0.7151 0.6199 0.555581669 \n#> 995   995  0.3584 0.0950 24 24 0.3083  1.1625 0.2450 -0.2458 0.9625 0.122511729 \n#> 996   996  0.3939 0.1697 17 17 0.4120  0.9562 0.3390 -0.4135 1.2014 0.169484321 \n#> 997   997  0.5205 0.0486 35 35 0.2204  2.3610 0.0182  0.0884 0.9525 0.009112230 \n#> 998   998  0.4206 0.0815 29 29 0.2854  1.4737 0.1406 -0.1388 0.9801 0.070283435 \n#> 999   999  0.0625 0.0244 83 83 0.1562  0.3999 0.6893 -0.2438 0.3687 0.344631179 \n#> 1000 1000  0.5547 0.0416 37 37 0.2039  2.7201 0.0065  0.1550 0.9544 0.003263493\n```\n:::\n\n\n\n\n\n## PB under an EE model\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 3))\nhist(dat$yi, breaks = 50, col = \"dodgerblue\", main = \"Effect Size\")\nplot(dat$yi, dat$pval1, pch = 19, col = ifelse(dat$pval1 <= 0.05, scales::alpha(\"firebrick\", 0.5), scales::alpha(\"black\", 0.5)),\n     main = \"P value (one tail) ~ Effect size\")\nabline(h = 0.05)\nplot(dat$yi, dat$pval, pch = 19, col = ifelse(dat$pval <= 0.05, scales::alpha(\"firebrick\", 0.5), scales::alpha(\"black\", 0.5)),\n     main = \"P value (two tails) ~ Effect size\")\nabline(h = 0.05)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-84-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## PB under an EE model\n\nThen, let's assume that our publishing system is very strict (extreme). You can publish only if $p \\leq 0.05$ on the expected direction. Then the true population of effect sizes will be truncated. Essentially we are assuming that $P(1|p \\leq 0.05) = 1$ and $P(1|p \\leq 0.05) = 0$.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# selecting\nsign <- dat$pval1 <= 0.05 & dat$zi > 0\ndat_pb <- dat[sign, ]\ndat_un <- dat[sample(1:nrow(dat), sum(sign)), ]\n\n# fitting EE model for the full vs selected (ignore k differences)\nfit <- rma(yi, vi, method = \"EE\", data = dat_un)\nfit_pb <- rma(yi, vi, method = \"EE\", data = dat_pb)\n```\n:::\n\n\n\n\n\n## PB under an EE model\n\nThen, let's assume that our publishing system is very strict (extreme). You can publish only if $p \\leq 0.05$ on the expected direction. Then the true population of effect sizes will be truncated. Essentially we are assuming that $P(1|p \\leq 0.05) = 1$ and $P(1|p \\leq 0.05) = 0$.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(compare_rma(fit, fit_pb), 3)\n#> fit: rma(yi = yi, vi = vi, data = dat_un, method = \"EE\")\n#> fit_pb: rma(yi = yi, vi = vi, data = dat_pb, method = \"EE\")\n#>                fit fit_pb\n#> b (intrcpt)  0.289  0.436\n#> se           0.009  0.008\n#> zval        32.003 51.811\n#> pval         0.000  0.000\n#> ci.lb        0.271  0.420\n#> ci.ub        0.307  0.453\n#> I2           0.955  0.000\n#> tau2         0.000  0.000\n```\n:::\n\n\n\n\n\n## PB under an EE model\n\nThe situation is even worse when we simulate a null effect. This strict selection results in committing type-1 error:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2023)\nk <- 1e3\nn <- round(runif(k, 10, 100))\ndat0 <- sim_studies(k = k, es = 0, tau2 = 0, n1 = n)\ndat0 <- summary(dat0)\n# compute 1 tail pvalue\ndat0$pval1 <- 1 - pnorm(dat0$zi)\n# selecting\nsign <- dat0$pval1 <= 0.05 & dat0$zi > 0\ndat_pb0 <- dat0[sign, ]\ndat_un0 <- dat0[sample(1:nrow(dat0), sum(sign)), ]\n\n# fitting EE model for the full vs selected (ignore k differences)\nfit0 <- rma(yi, vi, method = \"EE\", data = dat_un0)\nfit_pb0 <- rma(yi, vi, method = \"EE\", data = dat_pb0)\nround(compare_rma(fit0, fit_pb0), 3)\n#> fit0: rma(yi = yi, vi = vi, data = dat_un0, method = \"EE\")\n#> fit_pb0: rma(yi = yi, vi = vi, data = dat_pb0, method = \"EE\")\n#>               fit0 fit_pb0\n#> b (intrcpt) -0.006   0.363\n#> se           0.027   0.026\n#> zval        -0.220  14.015\n#> pval         0.826   0.000\n#> ci.lb       -0.059   0.312\n#> ci.ub        0.047   0.414\n#> I2           0.000   0.000\n#> tau2         0.000   0.000\n```\n:::\n\n\n\n\n\n## PB under an EE model\n\nAssuming to pick a very precise ($n = 1000$) and a very unprecise ($n = 20$) study, which one is more likely to have an effect size close to the true value?\n\n. . .\n\nThe precise study has a lower $\\epsilon_i$ thus is closer to $\\theta$. This relationship create a very insightful visual representation.\n\n. . .\n\nWhat could be the shape of the plot when plotting the precision (e.g., the sample size or the inverse of the variance) as a function of the effect size?\n\n## PB under an EE model\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|code-fold: true\nplot(dat$yi, sqrt(dat$vi), ylim=rev(range(dat$vi)), pch = 19, col = scales::alpha(\"black\", 0.5), cex = 1.5)\nabline(v = theta, lwd = 3, col = \"firebrick\")\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-88-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Publication Bias (PB) - Funnel Plot\n\nWe created a **funnel plot**. This is a **visual tool** to check the presence of asymmetry that could be caused by publication bias. If meta-analysis assumptions are respected, and there is no publication bias:\n\n- effects should be normally distributed around the average effect\n- more precise studies should be closer to the average effect\n- less precise studies could be equally distributed around the average effect\n\n## Publication Bias (PB) - Funnel Plot\n\nThe plot assume the typical funnel shape and there are not missing spots on the at the bottom. The presence of missing spots is a potential index of publication bias.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nfit <- rma(yi, vi, method = \"EE\", data = dat)\ndat$pb <- dat$pval <= 0.05\n\nwith(dat[dat$pb, ],\n     plot(yi, sei,\n          ylim = rev(range(dat$sei)),\n          xlab = latex2exp::TeX(\"$y_i$\"),\n          ylab = latex2exp::TeX(\"$\\\\sqrt{\\\\sigma_i^2}$\"),\n          xlim = range(dat$yi),\n          pch = 19,\n          col = scales::alpha(\"firebrick\", 0.5))\n)\n\nwith(dat[!dat$pb, ],\n     points(yi, sei, col = scales::alpha(\"black\", 0.5), pch = 19)\n)\n\nabline(v = fit$b[[1]], col = \"black\", lwd = 1.2)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-89-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Publication Bias (PB) - Funnel Plot\n\nThe plot assume the typical funnel shape and there are not missing spots on the at the bottom. The presence of missing spots is a potential index of publication bias.\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-90-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Robustness to PB - Fail-safe N\n\nThe Fail-safe N [@Rosenthal1979-yx] idea is very simple. Given a meta-analysis with a significant result (i.e., $p \\leq \\alpha$). How many null studies (i.e., $\\hat \\theta = 0$) do I need to obtain $p > \\alpha$?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetafor::fsn(yi, vi, data = dat)\n#> \n#> Fail-safe N Calculation Using the Rosenthal Approach\n#> \n#> Observed Significance Level: <.0001\n#> Target Significance Level:   0.05\n#> \n#> Fail-safe N: 832741\n```\n:::\n\n\n\n\n\n## Robustness to PB - Fail-safe N\n\nThere are several criticism to the Fail-safe N procedure:\n\n. . .\n\n- is not actually *detecting* the PB but suggesting the required PB size to remove the effect. A very large N suggest that even with PB, it is unlikely that the results could be completely changed by actually reporting null studies\n\n. . .\n\n- @Orwin1983-vu proposed a new method calculating the number of studies required to reduce the effect size to a given target\n\n. . .\n\n- @Rosenberg2005-ie proposed a method similar to Rosenthal [-@Rosenthal1979-yx] but combining the (weighted) effect sizes and not the p-values.\n\n\n## Detecting PB - Egger Regression\n\nA basic method to test the funnel plot asymmetry is using an the **Egger regression test**. Basically we calculate the relationship between $y_i$ and $\\sqrt{\\sigma^2_i}$. In the absence of asimmetry, the line slope should be not different from 0.\n\nWe can use the `metafor::regtest()` function:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\negger <- regtest(fit)\negger\n#> \n#> Regression Test for Funnel Plot Asymmetry\n#> \n#> Model:     fixed-effects meta-regression model\n#> Predictor: standard error\n#> \n#> Test for Funnel Plot Asymmetry: z = -0.3621, p = 0.7173\n#> Limit Estimate (as sei -> 0):   b =  0.3061 (CI: 0.2601, 0.3520)\n```\n:::\n\n\n\n\n\n## Publication Bias (PB) - Egger Regression\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-93-1.png){width=672}\n:::\n:::\n\n\n\n\n\nThis is a standard (meta) regression thus the number of studies, the precision of each study and heterogeneity influence the reliability (power, type-1 error rate, etc.) of the procedure.\n\n## Correcting PB - Trim and Fill\n\nThe Trim and Fill method [@Duval2000-ym] is used to impute the hypothetical missing studies according to the funnel plot and recomputing the meta-analysis effect. Shi and Lin [@Shi2019-pj] provide an updated overview of the method with some criticisms.\n\n. . .\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2023)\nk <- 100 # we increased k to better show the effect\ntheta <- 0.5\ntau2 <- 0.1\nn <- runif(k, 10, 100)\ndat <- sim_studies(k, theta, tau2, n)\ndat <- summary(dat)\ndatpb <- dat[dat$pval <= 0.1 & dat$zi > 0, ]\nfit <- rma(yi, vi, data = datpb, method = \"REML\")\n```\n:::\n\n\n\n\n\n## Correcting PB - Trim and Fill\n\nNow we can use the `metafor::trimfill()` function:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntaf <- metafor::trimfill(fit)\ntaf\n#> \n#> Estimated number of missing studies on the left side: 15 (SE = 5.4670)\n#> \n#> Random-Effects Model (k = 84; tau^2 estimator: REML)\n#> \n#> tau^2 (estimated amount of total heterogeneity): 0.0562 (SE = 0.0146)\n#> tau (square root of estimated tau^2 value):      0.2371\n#> I^2 (total heterogeneity / total variability):   61.61%\n#> H^2 (total variability / sampling variability):  2.60\n#> \n#> Test for Heterogeneity:\n#> Q(df = 83) = 210.3501, p-val < .0001\n#> \n#> Model Results:\n#> \n#> estimate      se     zval    pval   ci.lb   ci.ub      \n#>   0.5934  0.0339  17.5084  <.0001  0.5270  0.6598  *** \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\nThe trim-and-fill estimates that 15 are missing. The new effect size after including the studies is reduced and closer to the simulated value (but in this case still significant).\n\n## Correcting PB - Trim and Fill\n\nWe can also visualize the funnel plot highligting the points that are included by the method.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunnel(taf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nfunnel(taf)\negg <- regtest(fit)\negg_npb <- regtest(taf)\nse <- seq(0,1.8,length=100)\nlines(coef(egg$fit)[1] + coef(egg$fit)[2]*se, se, lwd=3, col = \"black\")\nlines(coef(egg_npb$fit)[1] + coef(egg_npb$fit)[2]*se, se, lwd=3, col = \"firebrick\")\nlegend(\"topleft\", legend = c(\"Original\", \"Corrected\"), fill = c(\"black\", \"firebrick\"))\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-97-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Why the funnel plot can be misleading?\n\nThis funnel plot show an evident asymmetry on the left side. Is there evidence of publication bias? What do you think?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\nk <- 50\nn1 <- round(runif(k, 10, 200))\nn2 <- round(runif(k, 10, 50))\ndat1 <- sim_studies(k, 0, 0, n1, add = list(x = 0))\ndat2 <- sim_studies(k, 0.5, 0.05, n2, add = list(x = 1))\ndat <- rbind(dat1, dat2)\nfit <- rma(yi, vi, dat = dat)\nfunnel(fit)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-98-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Why the funnel plot can be misleading?\n\nThe data are of course simulated and this is the code. What do you think now?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\nk <- 50\nn1 <- round(runif(k, 10, 200))\nn2 <- round(runif(k, 10, 50))\ndat1 <- sim_studies(k, 0, 0, n1, add = list(x = 0))\ndat2 <- sim_studies(k, 0.5, 0.05, n2, add = list(x = 1))\ndat <- rbind(dat1, dat2)\nfit <- rma(yi, vi, dat = dat)\nfunnel(fit)\n```\n:::\n\n\n\n\n\n## Why the funnel plot can be misleading?\n\nIn fact, these are two **unbiased** population of effect sizes. Extra source of heterogeneity could create asymmetry not related to PB.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\nfunnel(fit)\nfunnel(fit, col = dat$x + 1)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-100-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Why the funnel plot can be misleading?\n\nAlso the methods to detect/correct for PB are committing a false alarm:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregtest(fit)\n#> \n#> Regression Test for Funnel Plot Asymmetry\n#> \n#> Model:     mixed-effects meta-regression model\n#> Predictor: standard error\n#> \n#> Test for Funnel Plot Asymmetry: z =  6.2569, p < .0001\n#> Limit Estimate (as sei -> 0):   b = -0.2067 (CI: -0.3460, -0.0675)\n```\n:::\n\n\n\n\n\n## Why the funnel plot can be misleading?\n\nAlso the methods to detect/correct for PB are committing a false alarm:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrimfill(fit)\n#> \n#> Estimated number of missing studies on the left side: 32 (SE = 6.3553)\n#> \n#> Random-Effects Model (k = 132; tau^2 estimator: REML)\n#> \n#> tau^2 (estimated amount of total heterogeneity): 0.2183 (SE = 0.0337)\n#> tau (square root of estimated tau^2 value):      0.4672\n#> I^2 (total heterogeneity / total variability):   86.77%\n#> H^2 (total variability / sampling variability):  7.56\n#> \n#> Test for Heterogeneity:\n#> Q(df = 131) = 639.7238, p-val < .0001\n#> \n#> Model Results:\n#> \n#> estimate      se    zval    pval    ci.lb   ci.ub    \n#>   0.0281  0.0457  0.6142  0.5391  -0.0615  0.1177    \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\n## Why the funnel plot can be misleading?\n\nThe `regtest` can be applied also with moderators. The idea should be to take into account the moderators effects and then check for asymmetry.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfitm <- rma(yi, vi, mods = ~x, data = dat)\nregtest(fitm)\n#> \n#> Regression Test for Funnel Plot Asymmetry\n#> \n#> Model:     mixed-effects meta-regression model\n#> Predictor: standard error\n#> \n#> Test for Funnel Plot Asymmetry: z = -1.0277, p = 0.3041\n```\n:::\n\n\n\n\n\n## Why the funnel plot can be misleading?\n\nIn fact, the funnel plot on the raw dataset and on residuals looks quite different because the asymmetry was caused by the moderator.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndat$ri <- residuals(fitm)\nfitr <- rma(ri, vi, data = dat)\npar(mfrow = c(1, 2))\nplot_regtest(fit, main = \"Full model\")\nplot_regtest(fitr, main = \"Residuals\")\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-104-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Correcting PB - Selection Models (SM)\n\nSM are more than a tool for correcting for the PB. SM are formal models of PB that can help us understanding and simulating the PB.\n\nThe SM are composed by two parts:\n\n1. **Effect size model**: the unbiased data generation process. In our case basically the `sim_studies()` function.\n2. **Selection model**: the assumed process generating the biased selection of effect sizes\n\n**Selection models** can be based on the p-value (e.g., *p-curve* or *p-uniform*) and/or the effect size and variance (*Copas* model). We will see only models based on the p-value.\n\n## Correcting PB - Selection Models (SM)\n\nFormally, the random-effect meta-analysis probability density function (PDF) can be written as [e.g., @Citkowicz2017-ox]:\n\n$$\nf\\left(y_i \\mid \\beta, \\tau^2 ; \\sigma_i^2\\right)=\\frac{\\phi\\left(\\frac{y_i-\\Delta_i}{\\sqrt{\\sigma_i^2+\\tau^2}}\\right)}{\\int_{-\\infty}^{\\infty}  \\phi\\left(\\frac{Y_i-\\Delta_i}{\\sqrt{\\sigma_i^2+\\tau^2}}\\right) d y_i}\n$$\n\nWithout going into details, this is the PDF without any selection process (i.e., the **effect sizes model**).\n\n## Correcting PB - Selection Models (SM)\n\nIf we have a function linking the p-value with the probability of publishing (a **weight function**) $w(p_i)$ we can include it in the previous PDF, creating a weighted PDF.\n\n$$\nf\\left(y_i \\mid \\beta, \\tau^2 ; \\sigma_i^2\\right)=\\frac{\\mathrm{w}\\left(p_i\\right) \\phi\\left(\\frac{y_i-\\Delta_i}{\\sqrt{\\sigma_i^2+\\tau^2}}\\right)}{\\int_{-\\infty}^{\\infty} \\mathrm{w}\\left(p_i\\right) \\phi\\left(\\frac{Y_i-\\Delta_i}{\\sqrt{\\sigma_i^2+\\tau^2}}\\right)d y_i}\n$$\n\nEssentially, this new model take into account the selection process (the **weight function**) to estimate a new meta-analysis. In case of no selection (all weigths are the same) the model is the standard random-effects meta-analysis.\n\n## SM - Weigth function\n\nThe weigth function is a simple function that links the p-value with the probability of publishing. The simple example at the beginning (publishing only significant p-values) is a step weigth function.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- c(0, 0.05, 0.05, 1)\nw <- c(1, 1, 0, 0)\n\nplot(p, w, type = \"l\", xlab = \"p value\", ylab = \"Probability of Publishing\")\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-105-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## SM - Weigth function\n\nWe can add more steps to express a more complex selection process:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- c(0.001, 0.01, 0.05, 0.1, 0.8, 1)\nw <- c(1, 1, 0.9, 0.5, 0.1, 0.1)\nplot(p, w, type = \"s\", xlab = \"p value\", ylab = \"Probability of Publishing\")\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-106-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## SM - Weigth function\n\nOr we can draw a smooth function assuming certain parameters:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwbeta <- function(p, a = 1, b = 1) p^(a - 1) * (1 - p)^(b - 1)\npval <- seq(0, 1, 0.01)\n\nplot(pval, wbeta(pval, 1, 1), type = \"l\", ylim = c(0, 1), col = 1, lwd = 2,\n     xlab = \"p value\", ylab = \"Probability of Publishing\")\nlines(pval, wbeta(pval, 1, 2), col = 2, lwd = 2)\nlines(pval, wbeta(pval, 1, 5), col = 3, lwd = 2)\nlines(pval, wbeta(pval, 1, 50), col = 4, lwd = 2)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-107-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## SM - Weigth function\n\nWhatever the function, the SM estimate the parameters of the function and the meta-analysis parameters taking into account the weigths. \n\nClearly, in the presence of no bias the two models (with and without weights) are the same while with PB the estimation is different, probably reducing the effect size.\n\nIf the SM is correct (not possible in reality), the SM estimate the true effect even in the presence of bias. This is the strenght and elegance of the SM.\n\n## SM - Weigth functions\n\nThere are several weight functions:\n\n- the step model\n- the negative-exponential model\n- the beta model\n- ...\n\nFor an overview see the `metafor` documentation https://wviechtb.github.io/metafor/reference/selmodel.html\n\n## SM - Step model\n\nThe step model approximate the selection process with thresholds $\\alpha$ and the associated weight $w(p_i)$. For example:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsteps <- c(0.005, 0.01, 0.05, 0.10, 0.25, 0.35, 0.50, 0.65, 0.75, 0.90, 0.95, 0.99, 0.995, 1)\nmoderate_pb <- c(1, 0.99, 0.95, 0.80, 0.75, 0.65, 0.60, 0.55, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50)\nsevere_pb <- c(1, 0.99, 0.90, 0.75, 0.60, 0.50, 0.40, 0.35, 0.30, 0.25, 0.10, 0.10, 0.10, 0.10)\n\npar(mfrow = c(1, 2))\nplot(steps, moderate_pb, type = \"s\", xlab = \"p value\", ylab = \"Probability of Selection\", main = \"Moderate PB\", ylim = c(0, 1))\nabline(v = steps, col = \"grey\")\nplot(steps, severe_pb, type = \"s\", xlab = \"p value\", ylab = \"Probability of Selection\", main = \"Severe PB\", ylim = c(0, 1))\nabline(v = steps, col = \"grey\")\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-108-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## SM - Negative-Exponential\n\nThe Negative-Exponential model is very simple and intuitive. The weight function is $e^{-\\delta p_i}$ thus the single parameter $\\delta$ is the amount of bias. When $\\delta = 0$ there is no bias.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwnegexp <- function(p, delta){\n  exp((-delta)*p)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncurve(wnegexp(x, 0), ylim = c(0, 1), col = 1, lwd = 2, xlab = \"p value\", ylab = \"Probability of Selection\")\ncurve(wnegexp(x, 1), add = TRUE, col = 2, lwd = 2)\ncurve(wnegexp(x, 5), add = TRUE, col = 3, lwd = 2)\ncurve(wnegexp(x, 30), add = TRUE, col = 4, lwd = 2)\n\nlegend(\"topright\", legend = latex2exp::TeX(sprintf(\"$\\\\delta = %s$\", c(1, 2, 3, 4))), fill = 1:4)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-110-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Simulating data with PB\n\nThe strategy to simulate biased data is to sample from the `sim_studies()` function but to keep the studies using a probabilistic sampling based on the weight function.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\n\nk <- 500 # high number to check the results\nes <- 0 # H0 true\ntau2 <- 0.1\ndelta <- 5\ndat <- vector(mode = \"list\", k)\n\ni <- 1\nwhile(i <= k){\n  # generate data\n  n <- runif(1, 10, 100)\n  d <- summary(sim_studies(1, es, tau2, n))\n  # get one-tail p-value\n  pi <- 1 - pnorm(d$zi)\n  # get wi\n  wpi <- wnegexp(pi, delta)\n  keep <- rbinom(1, 1, wpi) == 1\n  if(keep){\n    dat[[i]] <- d\n    i <- i + 1\n  }\n}\n\ndat <- do.call(rbind, dat)\nfit <- rma(yi, vi, data = dat)\n```\n:::\n\n\n\n\n\n## Simulating data with PB\n\nLet's see some plots:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\npar(mfrow = c(1, 3))\nhist(dat$yi, breaks = 50, col = \"dodgerblue\")\nhist(1 - pnorm(dat$zi), breaks = 50, col = \"dodgerblue\")\nplot(dat$yi, dat$sei, ylim = c(rev(range(dat$sei)[2]), 0), xlim = c(-1, 2))\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-112-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Simulating data with PB\n\nLet's see the model result:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- rma(yi, vi, data = dat)\n```\n:::\n\n\n\n\n\n\n\n## Simulating data with PB\n\nLet's see the Egger regression test and the trim-and-fill procedure:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregtest(fit)\n#> \n#> Regression Test for Funnel Plot Asymmetry\n#> \n#> Model:     mixed-effects meta-regression model\n#> Predictor: standard error\n#> \n#> Test for Funnel Plot Asymmetry: z = 4.4739, p < .0001\n#> Limit Estimate (as sei -> 0):   b = 0.2017 (CI: 0.1235, 0.2799)\ntrimfill(fit)\n#> \n#> Estimated number of missing studies on the left side: 106 (SE = 14.6182)\n#> \n#> Random-Effects Model (k = 606; tau^2 estimator: REML)\n#> \n#> tau^2 (estimated amount of total heterogeneity): 0.0474 (SE = 0.0049)\n#> tau (square root of estimated tau^2 value):      0.2176\n#> I^2 (total heterogeneity / total variability):   56.94%\n#> H^2 (total variability / sampling variability):  2.32\n#> \n#> Test for Heterogeneity:\n#> Q(df = 605) = 1399.3991, p-val < .0001\n#> \n#> Model Results:\n#> \n#> estimate      se     zval    pval   ci.lb   ci.ub      \n#>   0.2927  0.0121  24.1497  <.0001  0.2689  0.3164  *** \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\n## Simulating data with PB\n\nThe two methods are detecting the PB but not correcting it appropriately. Let's see the SM using a `negexp` method:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsel <- selmodel(fit, type = \"negexp\", alternative = \"greater\")\nsel\n#> \n#> Random-Effects Model (k = 500; tau^2 estimator: ML)\n#> \n#> tau^2 (estimated amount of total heterogeneity): 0.0800 (SE = 0.0118)\n#> tau (square root of estimated tau^2 value):      0.2828\n#> \n#> Test for Heterogeneity:\n#> LRT(df = 1) = 115.9867, p-val < .0001\n#> \n#> Model Results:\n#> \n#> estimate      se    zval    pval    ci.lb   ci.ub    \n#>   0.0519  0.0381  1.3609  0.1735  -0.0228  0.1266    \n#> \n#> Test for Selection Model Parameters:\n#> LRT(df = 1) = 46.6783, p-val < .0001\n#> \n#> Selection Model Results:\n#> \n#> estimate      se     zval    pval   ci.lb   ci.ub      \n#>   4.7526  0.3818  12.4494  <.0001  4.0044  5.5008  *** \n#> \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\n\n\n## Simulating data with PB\n\nWe can also plot the results:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(sel)\n```\n\n::: {.cell-output-display}\n![](chapter5_files/figure-html/unnamed-chunk-117-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## PB Sensitivity analysis\n\n- The SM is correctly detecting, estimating and correcting the PB. But we simulated a pretty strong bias with $k = 500$ studies. In reality meta-analyses have few studies.\n- @Vevea2005-xc proposed to fix the weight function parameters to certain values representing different degree of selection and check how the model changes.\n- If the model parameters are affected after taking into account the SM, this could be considered as an index of PB.\n- This approach is really interesting in general but especially when $k$ is too small for estimating the SM\n- see `?selmodel` for information about performing sensitivity analysis with pre-specified weight functions\n\n## More on SM and Publication Bias\n\n- The SM documentation of `metafor::selmodel()` [https://wviechtb.github.io/metafor/reference/selmodel.html](https://www.youtube.com/watch?v=ucmOCuyCk-c)\n- Wolfgang Viechtbauer overview of PB [https://www.youtube.com/watch?v=ucmOCuyCk-c](https://www.youtube.com/watch?v=ucmOCuyCk-c)\n- @Harrer2021-go - Doing Meta-analysis in R - [Chapter 9](https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/pub-bias.html)\n- @McShane2016-bk for a nice introduction about publication bias and SM\n- Another good overview by @Jin2015-ik\n- See also @Guan2016-kn, @Maier2023-js and @Bartos2022-im for Bayesian approaches to PB\n\n## References <button class=\"btn\"><i class=\"fa fa-download\"></i><a href=\"data:text/x-bibtex;base64,QEFSVElDTEV7U2hpMjAxOS1waiwKICB0aXRsZSA9IHtUaGUgdHJpbS1hbmQtZmlsbCBtZXRob2QgZm9yIHB1YmxpY2F0aW9uIGJpYXM6IHByYWN0aWNhbCBndWlkZWxpbmVzCiAgYW5kIHJlY29tbWVuZGF0aW9ucyBiYXNlZCBvbiBhIGxhcmdlIGRhdGFiYXNlIG9mIG1ldGEtYW5hbHlzZXM6IHByYWN0aWNhbAogIGd1aWRlbGluZXMgYW5kIHJlY29tbWVuZGF0aW9ucyBiYXNlZCBvbiBhIGxhcmdlIGRhdGFiYXNlIG9mIG1ldGEtYW5hbHlzZXN9LAogIGF1dGhvciA9IHtTaGksIExpbnl1IGFuZCBMaW4sIExpZmVuZ30sCiAgam91cm5hbHRpdGxlID0ge01lZGljaW5lfSwKICBwdWJsaXNoZXIgPSB7T3ZpZCBUZWNobm9sb2dpZXMgKFdvbHRlcnMgS2x1d2VyIEhlYWx0aCl9LAogIHZvbHVtZSA9IHs5OH0sCiAgaXNzdWUgPSB7MjN9LAogIHBhZ2VzID0ge2UxNTk4N30sCiAgZGF0ZSA9IHsyMDE5LTA2fSwKICBkb2kgPSB7MTAuMTA5Ny9NRC4wMDAwMDAwMDAwMDE1OTg3fSwKICBwbWMgPSB7UE1DNjU3MTM3Mn0sCiAgcG1pZCA9IHszMTE2OTczNn0sCiAgaXNzbiA9IHswMDI1LTc5NzQsMTUzNi01OTY0fSwKICBhYnN0cmFjdCA9IHtQdWJsaWNhdGlvbiBiaWFzIGlzIGEgdHlwZSBvZiBzeXN0ZW1hdGljIGVycm9yIHdoZW4gc3ludGhlc2l6aW5nCiAgZXZpZGVuY2UgdGhhdCBjYW5ub3QgcmVwcmVzZW50IHRoZSB1bmRlcmx5aW5nIHRydXRoLiBDbGluaWNhbCBzdHVkaWVzIHdpdGgKICBmYXZvcmFibGUgcmVzdWx0cyBhcmUgbW9yZSBsaWtlbHkgcHVibGlzaGVkIGFuZCB0aHVzIGV4YWdnZXJhdGUgdGhlCiAgc3ludGhlc2l6ZWQgZXZpZGVuY2UgaW4gbWV0YS1hbmFseXNlcy4gVGhlIHRyaW0tYW5kLWZpbGwgbWV0aG9kIGlzIGEgcG9wdWxhcgogIHRvb2wgdG8gZGV0ZWN0IGFuZCBhZGp1c3QgZm9yIHB1YmxpY2F0aW9uIGJpYXMuIFNpbXVsYXRpb24gc3R1ZGllcyBoYXZlIGJlZW4KICBwZXJmb3JtZWQgdG8gYXNzZXNzIHRoaXMgbWV0aG9kLCBidXQgdGhleSBtYXkgbm90IGZ1bGx5IHJlcHJlc2VudCByZWFsaXN0aWMKICBzZXR0aW5ncyBhYm91dCBwdWJsaWNhdGlvbiBiaWFzLiBCYXNlZCBvbiByZWFsLXdvcmxkIG1ldGEtYW5hbHlzZXMsIHRoaXMKICBhcnRpY2xlIHByb3ZpZGVzIHByYWN0aWNhbCBndWlkZWxpbmVzIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIHVzaW5nIHRoZQogIHRyaW0tYW5kLWZpbGwgbWV0aG9kLiBXZSB1c2VkIGEgd29ya2VkIGlsbHVzdHJhdGl2ZSBleGFtcGxlIHRvIGRlbW9uc3RyYXRlIHRoZQogIGlkZWEgb2YgdGhlIHRyaW0tYW5kLWZpbGwgbWV0aG9kLCBhbmQgd2UgcmV2aWV3ZWQgdGhyZWUgZXN0aW1hdG9ycyAoUjAsIEwwLAogIGFuZCBRMCkgZm9yIGltcHV0aW5nIG1pc3Npbmcgc3R1ZGllcy4gQSByZXNhbXBsaW5nIG1ldGhvZCB3YXMgcHJvcG9zZWQgdG8KICBjYWxjdWxhdGUgUCB2YWx1ZXMgZm9yIGFsbCAzIGVzdGltYXRvcnMuIFdlIGFsc28gc3VtbWFyaXplZCBhdmFpbGFibGUKICBtZXRhLWFuYWx5c2lzIHNvZnR3YXJlIHByb2dyYW1zIGZvciBpbXBsZW1lbnRpbmcgdGhlIHRyaW0tYW5kLWZpbGwgbWV0aG9kLgogIE1vcmVvdmVyLCB3ZSBhcHBsaWVkIHRoZSBtZXRob2QgdG8gMjksOTMyIG1ldGEtYW5hbHlzZXMgZnJvbSB0aGUgQ29jaHJhbmUKICBEYXRhYmFzZSBvZiBTeXN0ZW1hdGljIFJldmlld3MsIGFuZCBlbXBpcmljYWxseSBldmFsdWF0ZWQgaXRzIG92ZXJhbGwKICBwZXJmb3JtYW5jZS4gV2UgY2FyZWZ1bGx5IGV4cGxvcmVkIHBvdGVudGlhbCBpc3N1ZXMgb2NjdXJyZWQgaW4gb3VyIGFuYWx5c2lzLgogIFRoZSBlc3RpbWF0b3JzIEwwIGFuZCBRMCBkZXRlY3RlZCBhdCBsZWFzdCBvbmUgbWlzc2luZyBzdHVkeSBpbiBtb3JlCiAgbWV0YS1hbmFseXNlcyB0aGFuIFIwLCB3aGlsZSBRMCBvZnRlbiBpbXB1dGVkIG1vcmUgbWlzc2luZyBzdHVkaWVzIHRoYW4gTDAuCiAgQWZ0ZXIgYWRkaW5nIGltcHV0ZWQgbWlzc2luZyBzdHVkaWVzLCB0aGUgc2lnbmlmaWNhbmNlIG9mIGhldGVyb2dlbmVpdHkgYW5kCiAgb3ZlcmFsbCBlZmZlY3Qgc2l6ZXMgY2hhbmdlZCBpbiBtYW55IG1ldGEtYW5hbHlzZXMuIEFsbCBlc3RpbWF0b3JzIGdlbmVyYWxseQogIGNvbnZlcmdlZCBmYXN0LiBIb3dldmVyLCBMMCBhbmQgUTAgZmFpbGVkIHRvIGNvbnZlcmdlIGluIGEgZmV3IG1ldGEtYW5hbHlzZXMKICB0aGF0IGNvbnRhaW5lZCBzdHVkaWVzIHdpdGggaWRlbnRpY2FsIGVmZmVjdCBzaXplcy4gQWxzbywgUCB2YWx1ZXMgcHJvZHVjZWQgYnkKICBkaWZmZXJlbnQgZXN0aW1hdG9ycyBjb3VsZCB5aWVsZCBkaWZmZXJlbnQgY29uY2x1c2lvbnMgb2YgcHVibGljYXRpb24gYmlhcwogIHNpZ25pZmljYW5jZS4gT3V0bGllcnMgYW5kIHRoZSBwcmUtc3BlY2lmaWVkIGRpcmVjdGlvbiBvZiBtaXNzaW5nIHN0dWRpZXMKICBjb3VsZCBoYXZlIGluZmx1ZW50aWFsIGltcGFjdCBvbiB0aGUgdHJpbS1hbmQtZmlsbCByZXN1bHRzLiBNZXRhLWFuYWx5c3RzIGFyZQogIHJlY29tbWVuZGVkIHRvIHBlcmZvcm0gdGhlIHRyaW0tYW5kLWZpbGwgbWV0aG9kIHdpdGggZ3JlYXQgY2F1dGlvbiB3aGVuIHVzaW5nCiAgbWV0YS1hbmFseXNpcyBzb2Z0d2FyZSBwcm9ncmFtcy4gU29tZSBkZWZhdWx0IHNldHRpbmdzIChlLmcuLCB0aGUgY2hvaWNlIG9mCiAgZXN0aW1hdG9ycyBhbmQgdGhlIGRpcmVjdGlvbiBvZiBtaXNzaW5nIHN0dWRpZXMpIGluIHRoZSBwcm9ncmFtcyBtYXkgbm90IGJlCiAgb3B0aW1hbCBmb3IgYSBjZXJ0YWluIG1ldGEtYW5hbHlzaXM7IHRoZXkgc2hvdWxkIGJlIGRldGVybWluZWQgb24gYQogIGNhc2UtYnktY2FzZSBiYXNpcy4gU2Vuc2l0aXZpdHkgYW5hbHlzZXMgYXJlIGVuY291cmFnZWQgdG8gZXhhbWluZSBlZmZlY3RzIG9mCiAgZGlmZmVyZW50IGVzdGltYXRvcnMgYW5kIG91dGx5aW5nIHN0dWRpZXMuIEFsc28sIHRoZSB0cmltLWFuZC1maWxsIGVzdGltYXRvcgogIHNob3VsZCBiZSByb3V0aW5lbHkgcmVwb3J0ZWQgaW4gbWV0YS1hbmFseXNlcywgYmVjYXVzZSB0aGUgcmVzdWx0cyBkZXBlbmQKICBoaWdobHkgb24gaXQufSwKICB1cmwgPSB7aHR0cHM6Ly93d3cubmNiaS5ubG0ubmloLmdvdi9wbWMvYXJ0aWNsZXMvUE1DNjU3MTM3Mi99LAogIGxhbmd1YWdlID0ge2VufQp9CgpAQVJUSUNMRXtWaWVjaHRiYXVlcjIwMDUtenQsCiAgdGl0bGUgPSB7QmlhcyBhbmQgZWZmaWNpZW5jeSBvZiBtZXRhLWFuYWx5dGljIHZhcmlhbmNlIGVzdGltYXRvcnMgaW4gdGhlCiAgcmFuZG9tLWVmZmVjdHMgbW9kZWx9LAogIGF1dGhvciA9IHtWaWVjaHRiYXVlciwgV29sZmdhbmd9LAogIGpvdXJuYWx0aXRsZSA9IHtKb3VybmFsIG9mIGVkdWNhdGlvbmFsIGFuZCBiZWhhdmlvcmFsIHN0YXRpc3RpY3M6IGEgcXVhcnRlcmx5CiAgcHVibGljYXRpb24gc3BvbnNvcmVkIGJ5IHRoZSBBbWVyaWNhbiBFZHVjYXRpb25hbCBSZXNlYXJjaCBBc3NvY2lhdGlvbiBhbmQgdGhlCiAgQW1lcmljYW4gU3RhdGlzdGljYWwgQXNzb2NpYXRpb259LAogIHB1Ymxpc2hlciA9IHtBbWVyaWNhbiBFZHVjYXRpb25hbCBSZXNlYXJjaCBBc3NvY2lhdGlvbiAoQUVSQSl9LAogIHZvbHVtZSA9IHszMH0sCiAgaXNzdWUgPSB7M30sCiAgcGFnZXMgPSB7MjYxLTI5M30sCiAgZGF0ZSA9IHsyMDA1LTA5fSwKICBkb2kgPSB7MTAuMzEwMi8xMDc2OTk4NjAzMDAwMzI2MX0sCiAgaXNzbiA9IHsxMDc2LTk5ODYsMTkzNS0xMDU0fSwKICBhYnN0cmFjdCA9IHtUaGUgbWV0YS1hbmFseXRpYyByYW5kb20gZWZmZWN0cyBtb2RlbCBhc3N1bWVzIHRoYXQgdGhlCiAgdmFyaWFiaWxpdHkgaW4gZWZmZWN0IHNpemUgZXN0aW1hdGVzIGRyYXduIGZyb20gYSBzZXQgb2Ygc3R1ZGllcyBjYW4gYmUKICBkZWNvbXBvc2VkIGludG8gdHdvIHBhcnRzOiBoZXRlcm9nZW5laXR5IGR1ZSB0byByYW5kb20gcG9wdWxhdGlvbiBlZmZlY3RzIGFuZAogIHNhbXBsaW5nIHZhcmlhbmNlLiBJbiB0aGlzIGNvbnRleHQsIHRoZSB1c3VhbCBnb2FsIGlzIHRvIGVzdGltYXRlIHRoZSBjZW50cmFsCiAgdGVuZGVuY3kgYW5kIHRoZSBhbW91bnQgb2YgaGV0ZXJvZ2VuZWl0eSBpbiB0aGUgcG9wdWxhdGlvbiBlZmZlY3Qgc2l6ZXMuIFRoZQogIGFtb3VudCBvZiBoZXRlcm9nZW5laXR5IGluIGEgc2V0IG9mIGVmZmVjdCBzaXplcyBoYXMgaW1wbGljYXRpb25zIHJlZ2FyZGluZwogIHRoZSBpbnRlcnByZXRhdGlvbiBvZiB0aGUgbWV0YS1hbmFseXRpYyBmaW5kaW5ncyBhbmQgb2Z0ZW4gc2VydmVzIGFzIGFuCiAgaW5kaWNhdG9yIGZvciB0aGUgcHJlc2VuY2Ugb2YgcG90ZW50aWFsIG1vZGVyYXRvciB2YXJpYWJsZXMuIEZpdmUgcG9wdWxhdGlvbgogIGhldGVyb2dlbmVpdHkgZXN0aW1hdG9ycyB3ZXJlIGNvbXBhcmVkIGluIHRoaXMgYXJ0aWNsZSBhbmFseXRpY2FsbHkgYW5kIHZpYQogIE1vbnRlIENhcmxvIHNpbXVsYXRpb25zIHdpdGggcmVzcGVjdCB0byB0aGVpciBiaWFzIGFuZCBlZmZpY2llbmN5Ln0sCiAgdXJsID0ge2h0dHBzOi8vc2Nob2xhci5nb29nbGUuY29tL2NpdGF0aW9ucz92aWV3X29wPXZpZXdfY2l0YXRpb24maGw9ZW4mdXNlcj1KODlSWEprQUFBQUomY2l0YXRpb25fZm9yX3ZpZXc9Sjg5UlhKa0FBQUFKOnFqTWFrRkhEeTdzQ30sCiAgbGFuZ3VhZ2UgPSB7ZW59Cn0KCkBBUlRJQ0xFe1Jvc2VudGhhbDE5NzkteXgsCiAgdGl0bGUgPSB7VGhlIGZpbGUgZHJhd2VyIHByb2JsZW0gYW5kIHRvbGVyYW5jZSBmb3IgbnVsbCByZXN1bHRzfSwKICBhdXRob3IgPSB7Um9zZW50aGFsLCBSb2JlcnR9LAogIGpvdXJuYWx0aXRsZSA9IHtQc3ljaG9sb2dpY2FsIGJ1bGxldGlufSwKICBwdWJsaXNoZXIgPSB7QW1lcmljYW4gUHN5Y2hvbG9naWNhbCBBc3NvY2lhdGlvbiAoQVBBKX0sCiAgdm9sdW1lID0gezg2fSwKICBpc3N1ZSA9IHszfSwKICBwYWdlcyA9IHs2MzgtNjQxfSwKICBkYXRlID0gezE5NzktMDV9LAogIGRvaSA9IHsxMC4xMDM3LzAwMzMtMjkwOS44Ni4zLjYzOH0sCiAgaXNzbiA9IHswMDMzLTI5MDksMTkzOS0xNDU1fSwKICB1cmwgPSB7aHR0cHM6Ly9wc3ljbmV0LmFwYS5vcmcvcmVjb3JkLzE5NzktMjc2MDItMDAxfSwKICBsYW5ndWFnZSA9IHtlbn0KfQoKQEFSVElDTEV7T3J3aW4xOTgzLXZ1LAogIHRpdGxlID0ge0EgZmFpbC1TYWZlTiBmb3IgZWZmZWN0IHNpemUgaW4gbWV0YS1hbmFseXNpc30sCiAgYXV0aG9yID0ge09yd2luLCBSb2JlcnQgR30sCiAgam91cm5hbHRpdGxlID0ge0pvdXJuYWwgb2YgZWR1Y2F0aW9uYWwgc3RhdGlzdGljc30sCiAgcHVibGlzaGVyID0ge0FtZXJpY2FuIEVkdWNhdGlvbmFsIFJlc2VhcmNoIEFzc29jaWF0aW9uIChBRVJBKX0sCiAgdm9sdW1lID0gezh9LAogIGlzc3VlID0gezJ9LAogIHBhZ2VzID0gezE1Ny0xNTl9LAogIGRhdGUgPSB7MTk4My0wNn0sCiAgZG9pID0gezEwLjMxMDIvMTA3Njk5ODYwMDgwMDIxNTd9LAogIGlzc24gPSB7MDM2Mi05NzkxLDIzMjgtMDczNX0sCiAgYWJzdHJhY3QgPSB7Um9zZW50aGFu4oCZcyAoMTk3OSkgY29uY2VwdCBvZiBmYWlsLXNhZmUgTiBoYXMgdGh1cyBmYXIgYmVlbgogIGFwcGxpZWQgdG8gcHJvYmFiaWxpdHkgbGV2ZWxzIGV4Y2x1c2l2ZWx5LiBUaGlzIG5vdGUgaW50cm9kdWNlcyBhIGZhaWwtc2FmZSBOCiAgZm9yIGVmZmVjdCBzaXplLn0sCiAgdXJsID0ge2h0dHBzOi8vam91cm5hbHMuc2FnZXB1Yi5jb20vZG9pL2Ficy8xMC4zMTAyLzEwNzY5OTg2MDA4MDAyMTU3fSwKICBsYW5ndWFnZSA9IHtlbn0KfQoKQEFSVElDTEV7Um9zZW5iZXJnMjAwNS1pZSwKICB0aXRsZSA9IHtUaGUgZmlsZS1kcmF3ZXIgcHJvYmxlbSByZXZpc2l0ZWQ6IGEgZ2VuZXJhbCB3ZWlnaHRlZCBtZXRob2QgZm9yCiAgY2FsY3VsYXRpbmcgZmFpbC1zYWZlIG51bWJlcnMgaW4gbWV0YS1hbmFseXNpc30sCiAgYXV0aG9yID0ge1Jvc2VuYmVyZywgTWljaGFlbCBTfSwKICBqb3VybmFsdGl0bGUgPSB7RXZvbHV0aW9uOyBpbnRlcm5hdGlvbmFsIGpvdXJuYWwgb2Ygb3JnYW5pYyBldm9sdXRpb259LAogIHB1Ymxpc2hlciA9IHtXaWxleX0sCiAgdm9sdW1lID0gezU5fSwKICBpc3N1ZSA9IHsyfSwKICBwYWdlcyA9IHs0NjQtNDY4fSwKICBkYXRlID0gezIwMDUtMDJ9LAogIGRvaSA9IHsxMC4xMTExL2ouMDAxNC0zODIwLjIwMDUudGIwMTAwNC54fSwKICBwbWlkID0gezE1ODA3NDMwfSwKICBpc3NuID0gezAwMTQtMzgyMCwxNTU4LTU2NDZ9LAogIGFic3RyYWN0ID0ge1F1YW50aXRhdGl2ZSBsaXRlcmF0dXJlIHJldmlld3Mgc3VjaCBhcyBtZXRhLWFuYWx5c2lzIGFyZSBiZWNvbWluZwogIGNvbW1vbiBpbiBldm9sdXRpb25hcnkgYmlvbG9neSBidXQgbWF5IGJlIHN0cm9uZ2x5IGFmZmVjdGVkIGJ5IHB1YmxpY2F0aW9uCiAgYmlhc2VzLiBVc2luZyBmYWlsLXNhZmUgbnVtYmVycyBpcyBhIHF1aWNrIHdheSB0byBlc3RpbWF0ZSB3aGV0aGVyIHB1YmxpY2F0aW9uCiAgYmlhcyBpcyBsaWtlbHkgdG8gYmUgYSBwcm9ibGVtIGZvciBhIHNwZWNpZmljIHN0dWR5LiBIb3dldmVyLCBwcmV2aW91c2x5CiAgc3VnZ2VzdGVkIGZhaWwtc2FmZSBjYWxjdWxhdGlvbnMgYXJlIHVud2VpZ2h0ZWQgYW5kIGFyZSBub3QgYmFzZWQgb24gdGhlCiAgZnJhbWV3b3JrIGluIHdoaWNoIG1vc3QgbWV0YS1hbmFseXNlcyBhcmUgcGVyZm9ybWVkLiBBIGdlbmVyYWwsIHdlaWdodGVkCiAgZmFpbC1zYWZlIGNhbGN1bGF0aW9uLCBncm91bmRlZCBpbiB0aGUgbWV0YS1hbmFseXNpcyBmcmFtZXdvcmssIGFwcGxpY2FibGUgdG8KICBib3RoIGZpeGVkLSBhbmQgcmFuZG9tLWVmZmVjdHMgbW9kZWxzLCBpcyBwcm9wb3NlZC4gUmVjZW50IG1ldGEtYW5hbHlzZXMKICBwdWJsaXNoZWQgaW4gRXZvbHV0aW9uIGFyZSB1c2VkIGZvciBpbGx1c3RyYXRpb24ufSwKICB1cmwgPSB7aHR0cHM6Ly9vbmxpbmVsaWJyYXJ5LndpbGV5LmNvbS9kb2kvYWJzLzEwLjExMTEvai4wMDE0LTM4MjAuMjAwNS50YjAxMDA0Lnh9LAogIGxhbmd1YWdlID0ge2VufQp9CgpAQVJUSUNMRXtDaXRrb3dpY3oyMDE3LW94LAogIHRpdGxlID0ge0EgcGFyc2ltb25pb3VzIHdlaWdodCBmdW5jdGlvbiBmb3IgbW9kZWxpbmcgcHVibGljYXRpb24gYmlhc30sCiAgYXV0aG9yID0ge0NpdGtvd2ljeiwgTWFydHluYSBhbmQgVmV2ZWEsIEphY2sgTH0sCiAgam91cm5hbHRpdGxlID0ge1BzeWNob2xvZ2ljYWwgbWV0aG9kc30sCiAgcHVibGlzaGVyID0ge3BzeWNuZXQuYXBhLm9yZ30sCiAgdm9sdW1lID0gezIyfSwKICBpc3N1ZSA9IHsxfSwKICBwYWdlcyA9IHsyOC00MX0sCiAgZGF0ZSA9IHsyMDE3LTAzfSwKICBkb2kgPSB7MTAuMTAzNy9tZXQwMDAwMTE5fSwKICBwbWlkID0gezI4MjUyOTk4fSwKICBpc3NuID0gezEwODItOTg5WCwxOTM5LTE0NjN9LAogIGFic3RyYWN0ID0ge1F1YW50aXRhdGl2ZSByZXNlYXJjaCBsaXRlcmF0dXJlIGlzIG9mdGVuIGJpYXNlZCBiZWNhdXNlIHN0dWRpZXMKICB0aGF0IGZhaWwgdG8gZmluZCBhIHNpZ25pZmljYW50IGVmZmVjdCAob3IgdGhhdCBkZW1vbnN0cmF0ZSBlZmZlY3RzIGluIGFuCiAgdW5kZXNpcmVkIG9yIHVuZXhwZWN0ZWQgZGlyZWN0aW9uKSBhcmUgbGVzcyBsaWtlbHkgdG8gYmUgcHVibGlzaGVkLiBUaGlzCiAgcGhlbm9tZW5vbiwgdGVybWVkIHB1YmxpY2F0aW9uIGJpYXMsIGNhbiBjYXVzZSBwcm9ibGVtcyB3aGVuIHJlc2VhcmNoZXJzCiAgYXR0ZW1wdCB0byBzeW50aGVzaXplIHJlc3VsdHMgdXNpbmcgbWV0YS1hbmFseXRpYyBtZXRob2RzLiBWYXJpb3VzIHRlY2huaXF1ZXMKICBleGlzdCB0aGF0IGF0dGVtcHQgdG8gZXN0aW1hdGUgYW5kIGNvcnJlY3QgbWV0YS1hbmFseXNlcyBmb3IgcHVibGljYXRpb24gYmlhcy4KICBIb3dldmVyLCB0aGVyZSBpcyBubyBzaW5nbGUgbWV0aG9kIHRoYXQgY2FuIChhKSBhY2NvdW50IGZvciBjb250aW51b3VzCiAgbW9kZXJhdG9ycyBieSBpbmNsdWRpbmcgdGhlbSB3aXRoaW4gdGhlIG1vZGVsLCAoYikgYWxsb3cgZm9yIHN1YnN0YW50aWFsIGRhdGEKICBoZXRlcm9nZW5laXR5LCAoYykgcHJvZHVjZSBhbiBhZGp1c3RlZCBtZWFuIGVmZmVjdCBzaXplLCAoZCkgaW5jbHVkZSBhIGZvcm1hbAogIHRlc3QgZm9yIHB1YmxpY2F0aW9uIGJpYXMsIGFuZCAoZSkgYWxsb3cgZm9yIGNvcnJlY3Rpb24gd2hlbiBvbmx5IGEgc21hbGwKICBudW1iZXIgb2YgZWZmZWN0cyBpcyBpbmNsdWRlZCBpbiB0aGUgYW5hbHlzaXMuIFRoaXMgYXJ0aWNsZSBkZXNjcmliZXMgYSBtZXRob2QKICB0aGF0IHdlIGJlbGlldmUgaGVscHMgZmlsbCB0aGF0IGdhcC4gVGhlIG1vZGVsIHVzZXMgdGhlIGJldGEgZGVuc2l0eSBhcyBhCiAgd2VpZ2h0IGZ1bmN0aW9uIHRoYXQgcmVwcmVzZW50cyB0aGUgc2VsZWN0aW9uIHByb2Nlc3MgYW5kIHByb3ZpZGVzIGFkanVzdGVkCiAgcGFyYW1ldGVyIGVzdGltYXRlcyB0aGF0IGFjY291bnQgZm9yIHB1YmxpY2F0aW9uIGJpYXMuIFVzZSBvZiB0aGUgYmV0YSBkZW5zaXR5CiAgYWxsb3dzIHVzIHRvIHJlcHJlc2VudCBzZWxlY3Rpb24gdXNpbmcgZmV3ZXIgcGFyYW1ldGVycyB0aGFuIHNpbWlsYXIgbW9kZWxzIHNvCiAgdGhhdCB0aGUgcHJvcG9zZWQgbW9kZWwgaXMgc3VpdGFibGUgZm9yIG1ldGEtYW5hbHlzZXMgdGhhdCBpbmNsdWRlIHJlbGF0aXZlbHkKICBmZXcgc3R1ZGllcy4gV2UgZXhwbGFpbiB0aGUgbW9kZWwgYW5kIGl0cyByYXRpb25hbGUsIGlsbHVzdHJhdGUgaXRzIHVzZSB3aXRoIGEKICByZWFsIGRhdGEgc2V0LCBhbmQgZGVzY3JpYmUgdGhlIHJlc3VsdHMgb2YgYSBzaW11bGF0aW9uIHN0dWR5IHRoYXQgc2hvd3MgdGhlCiAgbW9kZWwncyB1dGlsaXR5LiAoUHN5Y0lORk8gRGF0YWJhc2UgUmVjb3JkfSwKICB1cmwgPSB7aHR0cHM6Ly9wc3ljbmV0LmFwYS5vcmcvam91cm5hbHMvbWV0LzIyLzEvMjgvfSwKICBsYW5ndWFnZSA9IHtlbn0KfQoKQEFSVElDTEV7TWNTaGFuZTIwMTYtYmssCiAgdGl0bGUgPSB7QWRqdXN0aW5nIGZvciBwdWJsaWNhdGlvbiBiaWFzIGluIG1ldGEtYW5hbHlzaXM6IEFuIGV2YWx1YXRpb24gb2YKICBzZWxlY3Rpb24gbWV0aG9kcyBhbmQgc29tZSBjYXV0aW9uYXJ5IG5vdGVzOiBBbiBldmFsdWF0aW9uIG9mIHNlbGVjdGlvbgogIG1ldGhvZHMgYW5kIHNvbWUgY2F1dGlvbmFyeSBub3Rlc30sCiAgYXV0aG9yID0ge01jU2hhbmUsIEJsYWtlbGV5IEIgYW5kIELDtmNrZW5ob2x0LCBVbGYgYW5kIEhhbnNlbiwgS2Fyc3RlbiBUfSwKICBqb3VybmFsdGl0bGUgPSB7UGVyc3BlY3RpdmVzIG9uIHBzeWNob2xvZ2ljYWwgc2NpZW5jZTogYSBqb3VybmFsIG9mIHRoZQogIEFzc29jaWF0aW9uIGZvciBQc3ljaG9sb2dpY2FsIFNjaWVuY2V9LAogIHB1Ymxpc2hlciA9IHtTQUdFIFB1YmxpY2F0aW9uc30sCiAgdm9sdW1lID0gezExfSwKICBpc3N1ZSA9IHs1fSwKICBwYWdlcyA9IHs3MzAtNzQ5fSwKICBkYXRlID0gezIwMTYtMDl9LAogIGRvaSA9IHsxMC4xMTc3LzE3NDU2OTE2MTY2NjIyNDN9LAogIHBtaWQgPSB7Mjc2OTQ0Njd9LAogIGlzc24gPSB7MTc0NS02OTE2LDE3NDUtNjkyNH0sCiAgYWJzdHJhY3QgPSB7V2UgcmV2aWV3IGFuZCBldmFsdWF0ZSBzZWxlY3Rpb24gbWV0aG9kcywgYSBwcm9taW5lbnQgY2xhc3Mgb2YKICB0ZWNobmlxdWVzIGZpcnN0IHByb3Bvc2VkIGJ5IEhlZGdlcyAoMTk4NCkgdGhhdCBhc3Nlc3MgYW5kIGFkanVzdCBmb3IKICBwdWJsaWNhdGlvbiBiaWFzIGluIG1ldGEtYW5hbHlzaXMsIHZpYSBhbiBleHRlbnNpdmUgc2ltdWxhdGlvbiBzdHVkeS4gT3VyCiAgc2ltdWxhdGlvbiBjb3ZlcnMgYm90aCByZXN0cmljdGl2ZSBzZXR0aW5ncyBhcyB3ZWxsIGFzIG1vcmUgcmVhbGlzdGljIHNldHRpbmdzCiAgYW5kIHByb2NlZWRzIGFjcm9zcyBtdWx0aXBsZSBtZXRyaWNzIHRoYXQgYXNzZXNzIGRpZmZlcmVudCBhc3BlY3RzIG9mIG1vZGVsCiAgcGVyZm9ybWFuY2UuIFRoaXMgZXZhbHVhdGlvbiBpcyB0aW1lbHkgaW4gbGlnaHQgb2YgdHdvIHJlY2VudGx5IHByb3Bvc2VkCiAgYXBwcm9hY2hlcywgdGhlIHNvLWNhbGxlZCBwLWN1cnZlIGFuZCBwLXVuaWZvcm0gYXBwcm9hY2hlcywgdGhhdCBjYW4gYmUgdmlld2VkCiAgYXMgYWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSBvcmlnaW5hbCBIZWRnZXMgc2VsZWN0aW9uIG1ldGhvZAogIGFwcHJvYWNoLiBXZSBmaW5kIHRoYXQgdGhlIHAtY3VydmUgYW5kIHAtdW5pZm9ybSBhcHByb2FjaGVzIHBlcmZvcm0gcmVhc29uYWJseQogIHdlbGwgYnV0IG5vdCBhcyB3ZWxsIGFzIHRoZSBvcmlnaW5hbCBIZWRnZXMgYXBwcm9hY2ggaW4gdGhlIHJlc3RyaWN0aXZlCiAgc2V0dGluZyBmb3Igd2hpY2ggYWxsIHRocmVlIHdlcmUgZGVzaWduZWQuIFdlIGFsc28gZmluZCB0aGV5IHBlcmZvcm0gcG9vcmx5IGluCiAgbW9yZSByZWFsaXN0aWMgc2V0dGluZ3MsIHdoZXJlYXMgdmFyaWFudHMgb2YgdGhlIEhlZGdlcyBhcHByb2FjaCBwZXJmb3JtIHdlbGwuCiAgV2UgY29uY2x1ZGUgYnkgdXJnaW5nIGNhdXRpb24gaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHNlbGVjdGlvbiBtZXRob2RzOiBHaXZlbgogIHRoZSBpZGVhbGlzdGljIG1vZGVsIGFzc3VtcHRpb25zIHVuZGVybHlpbmcgc2VsZWN0aW9uIG1ldGhvZHMgYW5kIHRoZQogIHNlbnNpdGl2aXR5IG9mIHBvcHVsYXRpb24gYXZlcmFnZSBlZmZlY3Qgc2l6ZSBlc3RpbWF0ZXMgdG8gdGhlbSwgd2UgYWR2b2NhdGUKICB0aGF0IHNlbGVjdGlvbiBtZXRob2RzIHNob3VsZCBiZSB1c2VkIGxlc3MgZm9yIG9idGFpbmluZyBhIHNpbmdsZSBlc3RpbWF0ZQogIHRoYXQgcHVycG9ydHMgdG8gYWRqdXN0IGZvciBwdWJsaWNhdGlvbiBiaWFzIGV4IHBvc3QgYW5kIG1vcmUgZm9yIHNlbnNpdGl2aXR5CiAgYW5hbHlzaXMtdGhhdCBpcywgZXhwbG9yaW5nIHRoZSByYW5nZSBvZiBlc3RpbWF0ZXMgdGhhdCByZXN1bHQgZnJvbSBhc3N1bWluZwogIGRpZmZlcmVudCBmb3JtcyBvZiBhbmQgc2V2ZXJpdHkgb2YgcHVibGljYXRpb24gYmlhcy59LAogIHVybCA9IHtodHRwczovL2pvdXJuYWxzLnNhZ2VwdWIuY29tL2RvaS9hYnMvMTAuMTE3Ny8xNzQ1NjkxNjE2NjYyMjQzfSwKICBrZXl3b3JkcyA9IHtlZmZlY3Qgc2l6ZTsgbWV0YS1hbmFseXNpczsgcC1jdXJ2ZTsgcC11bmlmb3JtOyBzZWxlY3Rpb24gbWV0aG9kc30sCiAgbGFuZ3VhZ2UgPSB7ZW59Cn0KCkBBUlRJQ0xFe0JhcnRvczIwMjItaW0sCiAgdGl0bGUgPSB7QWRqdXN0aW5nIGZvciBwdWJsaWNhdGlvbiBiaWFzIGluIEpBU1AgYW5kIFI6IFNlbGVjdGlvbiBtb2RlbHMsCiAgUEVULVBFRVNFLCBhbmQgcm9idXN0IEJheWVzaWFuIG1ldGEtYW5hbHlzaXN9LAogIGF1dGhvciA9IHtCYXJ0b8WhLCBGcmFudGnFoWVrIGFuZCBNYWllciwgTWF4aW1pbGlhbiBhbmQgUXVpbnRhbmEsIERhbmllbCBTIGFuZAogIFdhZ2VubWFrZXJzLCBFcmljLUphbn0sCiAgam91cm5hbHRpdGxlID0ge0FkdmFuY2VzIGluIG1ldGhvZHMgYW5kIHByYWN0aWNlcyBpbiBwc3ljaG9sb2dpY2FsIHNjaWVuY2V9LAogIHB1Ymxpc2hlciA9IHtTQUdFIFB1YmxpY2F0aW9uc30sCiAgdm9sdW1lID0gezV9LAogIGlzc3VlID0gezN9LAogIHBhZ2VzID0gezI1MTUyNDU5MjIxMTA5Mn0sCiAgZGF0ZSA9IHsyMDIyLTA3fSwKICBkb2kgPSB7MTAuMTE3Ny8yNTE1MjQ1OTIyMTEwOTI1OX0sCiAgaXNzbiA9IHsyNTE1LTI0NTksMjUxNS0yNDY3fSwKICBhYnN0cmFjdCA9IHtNZXRhLWFuYWx5c2VzIGFyZSBlc3NlbnRpYWwgZm9yIGN1bXVsYXRpdmUgc2NpZW5jZSwgYnV0IHRoZWlyCiAgdmFsaWRpdHkgY2FuIGJlIGNvbXByb21pc2VkIGJ5IHB1YmxpY2F0aW9uIGJpYXMuIFRvIG1pdGlnYXRlIHRoZSBpbXBhY3Qgb2YKICBwdWJsaWNhdGlvbiBiaWFzLCBvbmUgbWF5IGFwcGx5IHB1YmxpY2F0aW9uLWJpYXMtYWRqdXN0bWVudCB0ZWNobmlxdWVzIHN1Y2ggYXMKICBwcmVjaXNpb24tZWZmZWN0IHRlc3QgYW5kIHByZWNpc2lvbi1lZmZlY3QgZXN0aW1hdGUgd2l0aCBzdGFuZGFyZCBlcnJvcnMKICAoUEVULVBFRVNFKSBhbmQgc2VsZWN0aW9uIG1vZGVscy4gVGhlc2UgbWV0aG9kcywgaW1wbGVtZW50ZWQgaW4gSkFTUCBhbmQgUiwKICBhbGxvdyByZXNlYXJjaGVycyB3aXRob3V0IHByb2dyYW1taW5nIGV4cGVyaWVuY2UgdG8gY29uZHVjdCBzdGF0ZS1vZi10aGUtYXJ0CiAgcHVibGljYXRpb24tYmlhcy1hZGp1c3RlZCBtZXRhLWFuYWx5c2lzLiBJbiB0aGlzIHR1dG9yaWFsLCB3ZSBkZW1vbnN0cmF0ZSBob3cKICB0byBjb25kdWN0IGEgcHVibGljYXRpb24tYmlhcy1hZGp1c3RlZCBtZXRhLWFuYWx5c2lzIGluIEpBU1AgYW5kIFIgYW5kCiAgaW50ZXJwcmV0IHRoZSByZXN1bHRzLiBGaXJzdCwgd2UgZXhwbGFpbiB0d28gZnJlcXVlbnRpc3QgYmlhcy1jb3JyZWN0aW9uCiAgbWV0aG9kczogUEVULVBFRVNFIGFuZCBzZWxlY3Rpb24gbW9kZWxzLiBTZWNvbmQsIHdlIGludHJvZHVjZSByb2J1c3QgQmF5ZXNpYW4KICBtZXRhLWFuYWx5c2lzLCBhIEJheWVzaWFuIGFwcHJvYWNoIHRoYXQgc2ltdWx0YW5lb3VzbHkgY29uc2lkZXJzIGJvdGgKICBQRVQtUEVFU0UgYW5kIHNlbGVjdGlvbiBtb2RlbHMuIFdlIGlsbHVzdHJhdGUgdGhlIG1ldGhvZG9sb2d5IG9uIGFuIGV4YW1wbGUKICBkYXRhIHNldCwgcHJvdmlkZSBhbiBpbnN0cnVjdGlvbmFsIHZpZGVvICggaHR0cHM6Ly9iaXQubHkvcHViYmlhcyApIGFuZCBhbgogIFItbWFya2Rvd24gc2NyaXB0ICggaHR0cHM6Ly9vc2YuaW8vdWhhZXcvICksIGFuZCBkaXNjdXNzIHRoZSBpbnRlcnByZXRhdGlvbiBvZgogIHRoZSByZXN1bHRzLiBGaW5hbGx5LCB3ZSBpbmNsdWRlIGNvbmNyZXRlIGd1aWRhbmNlIG9uIHJlcG9ydGluZyB0aGUKICBtZXRhLWFuYWx5dGljIHJlc3VsdHMgaW4gYW4gYWNhZGVtaWMgYXJ0aWNsZS59LAogIHVybCA9IHtodHRwczovL2pvdXJuYWxzLnNhZ2VwdWIuY29tL2RvaS9hYnMvMTAuMTE3Ny8yNTE1MjQ1OTIyMTEwOTI1OX0sCiAgbGFuZ3VhZ2UgPSB7ZW59Cn0KCkBBUlRJQ0xFe01haWVyMjAyMy1qcywKICB0aXRsZSA9IHtSb2J1c3QgQmF5ZXNpYW4gbWV0YS1hbmFseXNpczogQWRkcmVzc2luZyBwdWJsaWNhdGlvbiBiaWFzIHdpdGgKICBtb2RlbC1hdmVyYWdpbmd9LAogIGF1dGhvciA9IHtNYWllciwgTWF4aW1pbGlhbiBhbmQgQmFydG/FoSwgRnJhbnRpxaFlayBhbmQgV2FnZW5tYWtlcnMsIEVyaWMtSmFufSwKICBqb3VybmFsdGl0bGUgPSB7UHN5Y2hvbG9naWNhbCBtZXRob2RzfSwKICB2b2x1bWUgPSB7Mjh9LAogIGlzc3VlID0gezF9LAogIHBhZ2VzID0gezEwNy0xMjJ9LAogIGRhdGUgPSB7MjAyMy0wMn0sCiAgZG9pID0gezEwLjEwMzcvbWV0MDAwMDQwNX0sCiAgcG1pZCA9IHszNTU4ODA3NX0sCiAgaXNzbiA9IHsxMDgyLTk4OVgsMTkzOS0xNDYzfSwKICBhYnN0cmFjdCA9IHtNZXRhLWFuYWx5c2lzIGlzIGFuIGltcG9ydGFudCBxdWFudGl0YXRpdmUgdG9vbCBmb3IgY3VtdWxhdGl2ZQogIHNjaWVuY2UsIGJ1dCBpdHMgYXBwbGljYXRpb24gaXMgZnJ1c3RyYXRlZCBieSBwdWJsaWNhdGlvbiBiaWFzLiBJbiBvcmRlciB0bwogIHRlc3QgYW5kIGFkanVzdCBmb3IgcHVibGljYXRpb24gYmlhcywgd2UgZXh0ZW5kIG1vZGVsLWF2ZXJhZ2VkIEJheWVzaWFuCiAgbWV0YS1hbmFseXNpcyB3aXRoIHNlbGVjdGlvbiBtb2RlbHMuIFRoZSByZXN1bHRpbmcgcm9idXN0IEJheWVzaWFuCiAgbWV0YS1hbmFseXNpcyAoUm9CTUEpIG1ldGhvZG9sb2d5IGRvZXMgbm90IHJlcXVpcmUgYWxsLW9yLW5vbmUgZGVjaXNpb25zIGFib3V0CiAgdGhlIHByZXNlbmNlIG9mIHB1YmxpY2F0aW9uIGJpYXMsIGNhbiBxdWFudGlmeSBldmlkZW5jZSBpbiBmYXZvciBvZiB0aGUKICBhYnNlbmNlIG9mIHB1YmxpY2F0aW9uIGJpYXMsIGFuZCBwZXJmb3JtcyB3ZWxsIHVuZGVyIGhpZ2ggaGV0ZXJvZ2VuZWl0eS4gQnkKICBtb2RlbC1hdmVyYWdpbmcgb3ZlciBhIHNldCBvZiAxMiBtb2RlbHMsIFJvQk1BIGlzIHJlbGF0aXZlbHkgcm9idXN0IHRvIG1vZGVsCiAgbWlzc3BlY2lmaWNhdGlvbiBhbmQgc2ltdWxhdGlvbnMgc2hvdyB0aGF0IGl0IG91dHBlcmZvcm1zIGV4aXN0aW5nIG1ldGhvZHMuIFdlCiAgZGVtb25zdHJhdGUgdGhhdCBSb0JNQSBmaW5kcyBldmlkZW5jZSBmb3IgdGhlIGFic2VuY2Ugb2YgcHVibGljYXRpb24gYmlhcyBpbgogIFJlZ2lzdGVyZWQgUmVwbGljYXRpb24gUmVwb3J0cyBhbmQgcmVsaWFibHkgYXZvaWRzIGZhbHNlIHBvc2l0aXZlcy4gV2UgcHJvdmlkZQogIGFuIGltcGxlbWVudGF0aW9uIGluIFIgc28gdGhhdCByZXNlYXJjaGVycyBjYW4gZWFzaWx5IHVzZSB0aGUgbmV3IG1ldGhvZG9sb2d5CiAgaW4gcHJhY3RpY2UuIChQc3ljSW5mbyBEYXRhYmFzZSBSZWNvcmQgKGMpIDIwMjMgQVBBLCBhbGwgcmlnaHRzIHJlc2VydmVkKS59LAogIHVybCA9IHtodHRwczovL3BzeWNuZXQuYXBhLm9yZy9yZWNvcmQvMjAyMi02MjU1Mi0wMDF9LAogIGxhbmd1YWdlID0ge2VufQp9CgpAQVJUSUNMRXtHdWFuMjAxNi1rbiwKICB0aXRsZSA9IHtBIEJheWVzaWFuIGFwcHJvYWNoIHRvIG1pdGlnYXRpb24gb2YgcHVibGljYXRpb24gYmlhc30sCiAgYXV0aG9yID0ge0d1YW4sIE1haW1lIGFuZCBWYW5kZWtlcmNraG92ZSwgSm9hY2hpbX0sCiAgam91cm5hbHRpdGxlID0ge1BzeWNob25vbWljIGJ1bGxldGluIFwmIHJldmlld30sCiAgcHVibGlzaGVyID0ge1NwcmluZ2VyIFNjaWVuY2UgYW5kIEJ1c2luZXNzIE1lZGlhIExMQ30sCiAgdm9sdW1lID0gezIzfSwKICBpc3N1ZSA9IHsxfSwKICBwYWdlcyA9IHs3NC04Nn0sCiAgZGF0ZSA9IHsyMDE2LTAyfSwKICBkb2kgPSB7MTAuMzc1OC9zMTM0MjMtMDE1LTA4NjgtNn0sCiAgcG1pZCA9IHsyNjEyNjc3Nn0sCiAgaXNzbiA9IHsxMDY5LTkzODQsMTUzMS01MzIwfSwKICBhYnN0cmFjdCA9IHtUaGUgcmVsaWFiaWxpdHkgb2YgcHVibGlzaGVkIHJlc2VhcmNoIGZpbmRpbmdzIGluIHBzeWNob2xvZ3kgaGFzCiAgYmVlbiBhIHRvcGljIG9mIHJpc2luZyBjb25jZXJuLiBQdWJsaWNhdGlvbiBiaWFzLCBvciB0cmVhdGluZyBwb3NpdGl2ZQogIGZpbmRpbmdzIGRpZmZlcmVudGx5IGZyb20gbmVnYXRpdmUgZmluZGluZ3MsIGlzIGEgY29udHJpYnV0aW5nIGZhY3RvciB0byB0aGlzCiAgImNyaXNpcyBvZiBjb25maWRlbmNlLCIgaW4gdGhhdCBpdCBsaWtlbHkgaW5mbGF0ZXMgdGhlIG51bWJlciBvZgogIGZhbHNlLXBvc2l0aXZlIGVmZmVjdHMgaW4gdGhlIGxpdGVyYXR1cmUuIFdlIGRlbW9uc3RyYXRlIGEgQmF5ZXNpYW4gbW9kZWwKICBhdmVyYWdpbmcgYXBwcm9hY2ggdGhhdCB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHBvc3NpYmlsaXR5IG9mIHB1YmxpY2F0aW9uIGJpYXMKICBhbmQgYWxsb3dzIGZvciBhIGJldHRlciBlc3RpbWF0ZSBvZiB0cnVlIHVuZGVybHlpbmcgZWZmZWN0IHNpemUuIEFjY291bnRpbmcKICBmb3IgdGhlIHBvc3NpYmlsaXR5IG9mIGJpYXMgbGVhZHMgdG8gYSBtb3JlIGNvbnNlcnZhdGl2ZSBpbnRlcnByZXRhdGlvbiBvZgogIHB1Ymxpc2hlZCBzdHVkaWVzIGFzIHdlbGwgYXMgbWV0YS1hbmFseXNlcy4gV2UgcHJvdmlkZSBtYXRoZW1hdGljYWwgZGV0YWlscyBvZgogIHRoZSBtZXRob2QgYW5kIGV4YW1wbGVzLn0sCiAgdXJsID0ge2h0dHBzOi8vZHguZG9pLm9yZy8xMC4zNzU4L3MxMzQyMy0wMTUtMDg2OC02fSwKICBrZXl3b3JkcyA9IHtCYXllc2lhbiBpbmZlcmVuY2UgYW5kIHBhcmFtZXRlciBlc3RpbWF0aW9uOyBCYXllc2lhbiBzdGF0aXN0aWNzOwogIE1hdGggbW9kZWxpbmcgYW5kIG1vZGVsIHNlbGVjdGlvbjsgTWV0YS1hbmFseXNpcztCYXllc2lhbgogIFN0YXRpc3RpY3M7cmVwbGljYWJpbGl0eS1ib29rO2V4dHJhfSwKICBsYW5ndWFnZSA9IHtlbn0KfQoKQEFSVElDTEV7U2NoYWQyMDIwLWh0LAogIHRpdGxlID0ge0hvdyB0byBjYXBpdGFsaXplIG9uIGEgcHJpb3JpIGNvbnRyYXN0cyBpbiBsaW5lYXIgKG1peGVkKSBtb2RlbHM6IEEKICB0dXRvcmlhbH0sCiAgYXV0aG9yID0ge1NjaGFkLCBEYW5pZWwgSiBhbmQgVmFzaXNodGgsIFNocmF2YW4gYW5kIEhvaGVuc3RlaW4sIFN2ZW4gYW5kCiAgS2xpZWdsLCBSZWluaG9sZH0sCiAgam91cm5hbHRpdGxlID0ge0pvdXJuYWwgb2YgbWVtb3J5IGFuZCBsYW5ndWFnZX0sCiAgdm9sdW1lID0gezExMH0sCiAgcGFnZXMgPSB7MTA0MDM4fSwKICBkYXRlID0gezIwMjAtMDItMDF9LAogIGRvaSA9IHsxMC4xMDE2L2ouam1sLjIwMTkuMTA0MDM4fSwKICBpc3NuID0gezA3NDktNTk2WH0sCiAgYWJzdHJhY3QgPSB7RmFjdG9yaWFsIGV4cGVyaW1lbnRzIGluIHJlc2VhcmNoIG9uIG1lbW9yeSwgbGFuZ3VhZ2UsIGFuZCBpbgogIG90aGVyIGFyZWFzIGFyZSBvZnRlbiBhbmFseXplZCB1c2luZyBhbmFseXNpcyBvZiB2YXJpYW5jZSAoQU5PVkEpLiBIb3dldmVyLAogIGZvciBlZmZlY3RzIHdpdGggbW9yZSB0aGFuIG9uZSBudW1lcmF0b3IgZGVncmVlcyBvZiBmcmVlZG9tLCBlLmcuLCBmb3IKICBleHBlcmltZW50YWwgZmFjdG9ycyB3aXRoIG1vcmUgdGhhbiB0d28gbGV2ZWxzLCB0aGUgQU5PVkEgb21uaWJ1cyBGLXRlc3QgaXMKICBub3QgaW5mb3JtYXRpdmUgYWJvdXQgdGhlIHNvdXJjZSBvZiBhIG1haW4gZWZmZWN0IG9yIGludGVyYWN0aW9uLiBCZWNhdXNlCiAgcmVzZWFyY2hlcnMgdHlwaWNhbGx5IGhhdmUgc3BlY2lmaWMgaHlwb3RoZXNlcyBhYm91dCB3aGljaCBjb25kaXRpb24gbWVhbnMKICBkaWZmZXIgZnJvbSBlYWNoIG90aGVyLCBhIHByaW9yaSBjb250cmFzdHMgKGkuZS4sIGNvbXBhcmlzb25zIHBsYW5uZWQgYmVmb3JlCiAgdGhlIHNhbXBsZSBtZWFucyBhcmUga25vd24pIGJldHdlZW4gc3BlY2lmaWMgY29uZGl0aW9ucyBvciBjb21iaW5hdGlvbnMgb2YKICBjb25kaXRpb25zIGFyZSB0aGUgYXBwcm9wcmlhdGUgd2F5IHRvIHJlcHJlc2VudCBzdWNoIGh5cG90aGVzZXMgaW4gdGhlCiAgc3RhdGlzdGljYWwgbW9kZWwuIE1hbnkgcmVzZWFyY2hlcnMgaGF2ZSBwb2ludGVkIG91dCB0aGF0IGNvbnRyYXN0cyBzaG91bGQgYmUKICDigJx0ZXN0ZWQgaW5zdGVhZCBvZiwgcmF0aGVyIHRoYW4gYXMgYSBzdXBwbGVtZW50IHRvLCB0aGUgb3JkaW5hcnkg4oCYb21uaWJ1c+KAmSBGCiAgdGVzdOKAnSAoSGF5cywgMTk3MywgcC4gNjAxKS4gSW4gdGhpcyB0dXRvcmlhbCwgd2UgZXhwbGFpbiB0aGUgbWF0aGVtYXRpY3MKICB1bmRlcmx5aW5nIGRpZmZlcmVudCBraW5kcyBvZiBjb250cmFzdHMgKGkuZS4sIHRyZWF0bWVudCwgc3VtLCByZXBlYXRlZCwKICBwb2x5bm9taWFsLCBjdXN0b20sIG5lc3RlZCwgaW50ZXJhY3Rpb24gY29udHJhc3RzKSwgZGlzY3VzcyB0aGVpciBwcm9wZXJ0aWVzLAogIGFuZCBkZW1vbnN0cmF0ZSBob3cgdGhleSBhcmUgYXBwbGllZCBpbiB0aGUgUiBTeXN0ZW0gZm9yIFN0YXRpc3RpY2FsIENvbXB1dGluZwogIChSIENvcmUgVGVhbSwgMjAxOCkuIEluIHRoaXMgY29udGV4dCwgd2UgZXhwbGFpbiB0aGUgZ2VuZXJhbGl6ZWQgaW52ZXJzZSB3aGljaAogIGlzIG5lZWRlZCB0byBjb21wdXRlIHRoZSBjb2VmZmljaWVudHMgZm9yIGNvbnRyYXN0cyB0aGF0IHRlc3QgaHlwb3RoZXNlcyB0aGF0CiAgYXJlIG5vdCBjb3ZlcmVkIGJ5IHRoZSBkZWZhdWx0IHNldCBvZiBjb250cmFzdHMuIEEgZGV0YWlsZWQgdW5kZXJzdGFuZGluZyBvZgogIGNvbnRyYXN0IGNvZGluZyBpcyBjcnVjaWFsIGZvciBzdWNjZXNzZnVsIGFuZCBjb3JyZWN0IHNwZWNpZmljYXRpb24gaW4gbGluZWFyCiAgbW9kZWxzIChpbmNsdWRpbmcgbGluZWFyIG1peGVkIG1vZGVscykuIENvbnRyYXN0cyBkZWZpbmVkIGEgcHJpb3JpIHlpZWxkIGZhcgogIG1vcmUgdXNlZnVsIGNvbmZpcm1hdG9yeSB0ZXN0cyBvZiBleHBlcmltZW50YWwgaHlwb3RoZXNlcyB0aGFuIHN0YW5kYXJkCiAgb21uaWJ1cyBGLXRlc3RzLiBSZXByb2R1Y2libGUgY29kZSBpcyBhdmFpbGFibGUgZnJvbSBodHRwczovL29zZi5pby83dWtmNi8ufSwKICB1cmwgPSB7aHR0cHM6Ly93d3cuc2NpZW5jZWRpcmVjdC5jb20vc2NpZW5jZS9hcnRpY2xlL3BpaS9TMDc0OTU5NlgxOTMwMDY5NX0sCiAga2V5d29yZHMgPSB7Q29udHJhc3RzOyBOdWxsIGh5cG90aGVzaXMgc2lnbmlmaWNhbmNlIHRlc3Rpbmc7IExpbmVhciBtb2RlbHM7IEEKICBwcmlvcmkgaHlwb3RoZXNlcztCYXllc2lhbiBTdGF0aXN0aWNzfQp9CgpAQk9PS3tIYXJyZXIyMDIxLWdvLAogIHRpdGxlID0ge0RvaW5nIG1ldGEtYW5hbHlzaXMgd2l0aCBSOiBBIGhhbmRzLW9uIGd1aWRlfSwKICBhdXRob3IgPSB7SGFycmVyLCBNYXRoaWFzIGFuZCBDdWlqcGVycywgUGltIGFuZCBGdXJ1a2F3YSwgVG9zaGkgYW5kIEViZXJ0LAogIERhdmlkfSwKICBwdWJsaXNoZXIgPSB7Q1JDIFByZXNzfSwKICBsb2NhdGlvbiA9IHtMb25kb24sIEVuZ2xhbmR9LAogIGVkaXRpb24gPSB7MXN0fSwKICBkYXRlID0gezIwMjEtMDktMTN9LAogIHBhZ2V0b3RhbCA9IHs0NzR9LAogIGlzYm4gPSB7OTc4MDM2NzYxMDA3NH0sCiAgbGFuZ3VhZ2UgPSB7ZW59Cn0KCkBBUlRJQ0xFe0R1dmFsMjAwMC15bSwKICB0aXRsZSA9IHtUcmltIGFuZCBmaWxsOiBBIHNpbXBsZSBmdW5uZWwtcGxvdC1iYXNlZCBtZXRob2Qgb2YgdGVzdGluZyBhbmQKICBhZGp1c3RpbmcgZm9yIHB1YmxpY2F0aW9uIGJpYXMgaW4gbWV0YS1hbmFseXNpc30sCiAgYXV0aG9yID0ge0R1dmFsLCBTIGFuZCBUd2VlZGllLCBSfSwKICBqb3VybmFsdGl0bGUgPSB7QmlvbWV0cmljc30sCiAgcHVibGlzaGVyID0ge1dpbGV5fSwKICB2b2x1bWUgPSB7NTZ9LAogIGlzc3VlID0gezJ9LAogIHBhZ2VzID0gezQ1NS00NjN9LAogIGRhdGUgPSB7MjAwMC0wNn0sCiAgZG9pID0gezEwLjExMTEvai4wMDA2LTM0MXguMjAwMC4wMDQ1NS54fSwKICBwbWlkID0gezEwODc3MzA0fSwKICBpc3NuID0gezAwMDYtMzQxWCwxNTQxLTA0MjB9LAogIGFic3RyYWN0ID0ge1dlIHN0dWR5IHJlY2VudGx5IGRldmVsb3BlZCBub25wYXJhbWV0cmljIG1ldGhvZHMgZm9yIGVzdGltYXRpbmcKICB0aGUgbnVtYmVyIG9mIG1pc3Npbmcgc3R1ZGllcyB0aGF0IG1pZ2h0IGV4aXN0IGluIGEgbWV0YS1hbmFseXNpcyBhbmQgdGhlCiAgZWZmZWN0IHRoYXQgdGhlc2Ugc3R1ZGllcyBtaWdodCBoYXZlIGhhZCBvbiBpdHMgb3V0Y29tZS4gVGhlc2UgYXJlIHNpbXBsZQogIHJhbmstYmFzZWQgZGF0YSBhdWdtZW50YXRpb24gdGVjaG5pcXVlcywgd2hpY2ggZm9ybWFsaXplIHRoZSB1c2Ugb2YgZnVubmVsCiAgcGxvdHMuIFdlIHNob3cgdGhhdCB0aGV5IHByb3ZpZGUgZWZmZWN0aXZlIGFuZCByZWxhdGl2ZWx5IHBvd2VyZnVsIHRlc3RzIGZvcgogIGV2YWx1YXRpbmcgdGhlIGV4aXN0ZW5jZSBvZiBzdWNoIHB1YmxpY2F0aW9uIGJpYXMuIEFmdGVyIGFkanVzdGluZyBmb3IgbWlzc2luZwogIHN0dWRpZXMsIHdlIGZpbmQgdGhhdCB0aGUgcG9pbnQgZXN0aW1hdGUgb2YgdGhlIG92ZXJhbGwgZWZmZWN0IHNpemUgaXMKICBhcHByb3hpbWF0ZWx5IGNvcnJlY3QgYW5kIGNvdmVyYWdlIG9mIHRoZSBlZmZlY3Qgc2l6ZSBjb25maWRlbmNlIGludGVydmFscyBpcwogIHN1YnN0YW50aWFsbHkgaW1wcm92ZWQsIGluIG1hbnkgY2FzZXMgcmVjb3ZlcmluZyB0aGUgbm9taW5hbCBjb25maWRlbmNlIGxldmVscwogIGVudGlyZWx5LiBXZSBpbGx1c3RyYXRlIHRoZSB0cmltIGFuZCBmaWxsIG1ldGhvZCBvbiBleGlzdGluZyBtZXRhLWFuYWx5c2VzIG9mCiAgc3R1ZGllcyBpbiBjbGluaWNhbCB0cmlhbHMgYW5kIHBzeWNob21ldHJpY3MufSwKICB1cmwgPSB7aHR0cHM6Ly9vbmxpbmVsaWJyYXJ5LndpbGV5LmNvbS9kb2kvMTAuMTExMS9qLjAwMDYtMzQxWC4yMDAwLjAwNDU1Lnh9LAogIGtleXdvcmRzID0ge01ldGEtYW5hbHlzaXN9LAogIGxhbmd1YWdlID0ge2VufQp9CgpAQVJUSUNMRXtWZXJvbmlraTIwMTYtbncsCiAgdGl0bGUgPSB7TWV0aG9kcyB0byBlc3RpbWF0ZSB0aGUgYmV0d2Vlbi1zdHVkeSB2YXJpYW5jZSBhbmQgaXRzIHVuY2VydGFpbnR5IGluCiAgbWV0YS1hbmFseXNpc30sCiAgYXV0aG9yID0ge1Zlcm9uaWtpLCBBcmV0aSBBbmdlbGlraSBhbmQgSmFja3NvbiwgRGFuIGFuZCBWaWVjaHRiYXVlciwgV29sZmdhbmcKICBhbmQgQmVuZGVyLCBSYWxmIGFuZCBCb3dkZW4sIEphY2sgYW5kIEtuYXBwLCBHdWlkbyBhbmQgS3VzcywgT2xpdmVyIGFuZAogIEhpZ2dpbnMsIEp1bGlhbiBQIFQgYW5kIExhbmdhbiwgRGVhbiBhbmQgU2FsYW50aSwgR2VvcmdpYX0sCiAgam91cm5hbHRpdGxlID0ge1Jlc2VhcmNoIHN5bnRoZXNpcyBtZXRob2RzfSwKICBwdWJsaXNoZXIgPSB7V2lsZXl9LAogIHZvbHVtZSA9IHs3fSwKICBpc3N1ZSA9IHsxfSwKICBwYWdlcyA9IHs1NS03OX0sCiAgZGF0ZSA9IHsyMDE2LTAzfSwKICBkb2kgPSB7MTAuMTAwMi9qcnNtLjExNjR9LAogIHBtYyA9IHtQTUM0OTUwMDMwfSwKICBwbWlkID0gezI2MzMyMTQ0fSwKICBpc3NuID0gezE3NTktMjg3OSwxNzU5LTI4ODd9LAogIGFic3RyYWN0ID0ge01ldGEtYW5hbHlzZXMgYXJlIHR5cGljYWxseSB1c2VkIHRvIGVzdGltYXRlIHRoZSBvdmVyYWxsL21lYW4gb2YKICBhbiBvdXRjb21lIG9mIGludGVyZXN0LiBIb3dldmVyLCBpbmZlcmVuY2UgYWJvdXQgYmV0d2Vlbi1zdHVkeSB2YXJpYWJpbGl0eSwKICB3aGljaCBpcyB0eXBpY2FsbHkgbW9kZWxsZWQgdXNpbmcgYSBiZXR3ZWVuLXN0dWR5IHZhcmlhbmNlIHBhcmFtZXRlciwgaXMKICB1c3VhbGx5IGFuIGFkZGl0aW9uYWwgYWltLiBUaGUgRGVyU2ltb25pYW4gYW5kIExhaXJkIG1ldGhvZCwgY3VycmVudGx5IHdpZGVseQogIHVzZWQgYnkgZGVmYXVsdCB0byBlc3RpbWF0ZSB0aGUgYmV0d2Vlbi1zdHVkeSB2YXJpYW5jZSwgaGFzIGJlZW4gbG9uZwogIGNoYWxsZW5nZWQuIE91ciBhaW0gaXMgdG8gaWRlbnRpZnkga25vd24gbWV0aG9kcyBmb3IgZXN0aW1hdGlvbiBvZiB0aGUKICBiZXR3ZWVuLXN0dWR5IHZhcmlhbmNlIGFuZCBpdHMgY29ycmVzcG9uZGluZyB1bmNlcnRhaW50eSwgYW5kIHRvIHN1bW1hcmlzZSB0aGUKICBzaW11bGF0aW9uIGFuZCBlbXBpcmljYWwgZXZpZGVuY2UgdGhhdCBjb21wYXJlcyB0aGVtLiBXZSBpZGVudGlmaWVkIDE2CiAgZXN0aW1hdG9ycyBmb3IgdGhlIGJldHdlZW4tc3R1ZHkgdmFyaWFuY2UsIHNldmVuIG1ldGhvZHMgdG8gY2FsY3VsYXRlCiAgY29uZmlkZW5jZSBpbnRlcnZhbHMsIGFuZCBzZXZlcmFsIGNvbXBhcmF0aXZlIHN0dWRpZXMuIFNpbXVsYXRpb24gc3R1ZGllcwogIHN1Z2dlc3QgdGhhdCBmb3IgYm90aCBkaWNob3RvbW91cyBhbmQgY29udGludW91cyBkYXRhIHRoZSBlc3RpbWF0b3IgcHJvcG9zZWQKICBieSBQYXVsZSBhbmQgTWFuZGVsIGFuZCBmb3IgY29udGludW91cyBkYXRhIHRoZSByZXN0cmljdGVkIG1heGltdW0gbGlrZWxpaG9vZAogIGVzdGltYXRvciBhcmUgYmV0dGVyIGFsdGVybmF0aXZlcyB0byBlc3RpbWF0ZSB0aGUgYmV0d2Vlbi1zdHVkeSB2YXJpYW5jZS4KICBCYXNlZCBvbiB0aGUgc2NlbmFyaW9zIGFuZCByZXN1bHRzIHByZXNlbnRlZCBpbiB0aGUgcHVibGlzaGVkIHN0dWRpZXMsIHdlCiAgcmVjb21tZW5kIHRoZSBRLXByb2ZpbGUgbWV0aG9kIGFuZCB0aGUgYWx0ZXJuYXRpdmUgYXBwcm9hY2ggYmFzZWQgb24gYQogICdnZW5lcmFsaXNlZCBDb2NocmFuIGJldHdlZW4tc3R1ZHkgdmFyaWFuY2Ugc3RhdGlzdGljJyB0byBjb21wdXRlCiAgY29ycmVzcG9uZGluZyBjb25maWRlbmNlIGludGVydmFscyBhcm91bmQgdGhlIHJlc3VsdGluZyBlc3RpbWF0ZXMuIE91cgogIHJlY29tbWVuZGF0aW9ucyBhcmUgYmFzZWQgb24gYSBxdWFsaXRhdGl2ZSBldmFsdWF0aW9uIG9mIHRoZSBleGlzdGluZwogIGxpdGVyYXR1cmUgYW5kIGV4cGVydCBjb25zZW5zdXMuIEV2aWRlbmNlLWJhc2VkIHJlY29tbWVuZGF0aW9ucyByZXF1aXJlIGFuCiAgZXh0ZW5zaXZlIHNpbXVsYXRpb24gc3R1ZHkgd2hlcmUgYWxsIG1ldGhvZHMgd291bGQgYmUgY29tcGFyZWQgdW5kZXIgdGhlIHNhbWUKICBzY2VuYXJpb3MufSwKICB1cmwgPSB7aHR0cHM6Ly9vbmxpbmVsaWJyYXJ5LndpbGV5LmNvbS9kb2kvMTAuMTAwMi9qcnNtLjExNjR9LAogIGZpbGUgPSB7VmVyb25pa2kgZXQgYWwuIDIwMTYgLSBNZXRob2RzIHRvIGVzdGltYXRlIHRoZSBiZXR3ZWVuLXN0dWR5IHZhcmlhbmNlIGFuZCBpdHMgdW5jZXJ0YWludHkgaW4gbWV0YS1hbmFseXNpcy5wZGZ9LAogIGtleXdvcmRzID0ge2JpYXM7IGNvbmZpZGVuY2UgaW50ZXJ2YWw7IGNvdmVyYWdlIHByb2JhYmlsaXR5OyBoZXRlcm9nZW5laXR5OwogIG1lYW4gc3F1YXJlZCBlcnJvcn0sCiAgbGFuZ3VhZ2UgPSB7ZW59Cn0KCkBNSVNDe0JvcmVuc3RlaW4yMDA5LW1vLAogIHRpdGxlID0ge0ludHJvZHVjdGlvbiB0byB7TWV0YS1BbmFseXNpc319LAogIGF1dGhvciA9IHtCb3JlbnN0ZWluLCBNaWNoYWVsIGFuZCBIZWRnZXMsIExhcnJ5IFYgYW5kIEhpZ2dpbnMsIEp1bGlhbiBQIFQgYW5kCiAgUm90aHN0ZWluLCBIYW5uYWggUn0sCiAgZGF0ZSA9IHsyMDA5fSwKICBkb2kgPSB7MTAuMTAwMi85NzgwNDcwNzQzMzg2fSwKICB1cmwgPSB7aHR0cDovL2R4LmRvaS5vcmcvMTAuMTAwMi85NzgwNDcwNzQzMzg2fQp9CgpAQVJUSUNMRXtSaWxleTIwMTEtaHAsCiAgdGl0bGUgPSB7SW50ZXJwcmV0YXRpb24gb2YgcmFuZG9tIGVmZmVjdHMgbWV0YS1hbmFseXNlc30sCiAgYXV0aG9yID0ge1JpbGV5LCBSaWNoYXJkIEQgYW5kIEhpZ2dpbnMsIEp1bGlhbiBQIFQgYW5kIERlZWtzLCBKb25hdGhhbiBKfSwKICBqb3VybmFsdGl0bGUgPSB7Qk1KfSwKICB2b2x1bWUgPSB7MzQyfSwKICBwYWdlcyA9IHtkNTQ5fSwKICBkYXRlID0gezIwMTEtMDItMTB9LAogIGRvaSA9IHsxMC4xMTM2L2Jtai5kNTQ5fSwKICBwbWlkID0gezIxMzEwNzk0fSwKICBpc3NuID0gezA5NTktODEzOCwxNzU2LTE4MzN9LAogIHVybCA9IHtodHRwOi8vZHguZG9pLm9yZy8xMC4xMTM2L2Jtai5kNTQ5fSwKICBsYW5ndWFnZSA9IHtlbn0KfQoKQEFSVElDTEV7SW50SG91dDIwMTYtc3osCiAgdGl0bGUgPSB7UGxlYSBmb3Igcm91dGluZWx5IHByZXNlbnRpbmcgcHJlZGljdGlvbiBpbnRlcnZhbHMgaW4gbWV0YS1hbmFseXNpc30sCiAgYXV0aG9yID0ge0ludEhvdXQsIEpvYW5uYSBhbmQgSW9hbm5pZGlzLCBKb2huIFAgQSBhbmQgUm92ZXJzLCBNYXJvZXNrYSBNIGFuZAogIEdvZW1hbiwgSmVsbGUgSn0sCiAgam91cm5hbHRpdGxlID0ge0JNSiBvcGVufSwKICB2b2x1bWUgPSB7Nn0sCiAgaXNzdWUgPSB7N30sCiAgcGFnZXMgPSB7ZTAxMDI0N30sCiAgZGF0ZSA9IHsyMDE2LTA3LTEyfSwKICBkb2kgPSB7MTAuMTEzNi9ibWpvcGVuLTIwMTUtMDEwMjQ3fSwKICBwbWMgPSB7UE1DNDk0Nzc1MX0sCiAgcG1pZCA9IHsyNzQwNjYzN30sCiAgaXNzbiA9IHsyMDQ0LTYwNTV9LAogIGFic3RyYWN0ID0ge09CSkVDVElWRVM6IEV2YWx1YXRpbmcgdGhlIHZhcmlhdGlvbiBpbiB0aGUgc3RyZW5ndGggb2YgdGhlIGVmZmVjdAogIGFjcm9zcyBzdHVkaWVzIGlzIGEga2V5IGZlYXR1cmUgb2YgbWV0YS1hbmFseXNlcy4gVGhpcyB2YXJpYWJpbGl0eSBpcwogIHJlZmxlY3RlZCBieSBtZWFzdXJlcyBsaWtlIM+EKDIpIG9yIEkoMiksIGJ1dCB0aGVpciBjbGluaWNhbCBpbnRlcnByZXRhdGlvbiBpcwogIG5vdCBzdHJhaWdodGZvcndhcmQuIEEgcHJlZGljdGlvbiBpbnRlcnZhbCBpcyBsZXNzIGNvbXBsaWNhdGVkOiBpdCBwcmVzZW50cwogIHRoZSBleHBlY3RlZCByYW5nZSBvZiB0cnVlIGVmZmVjdHMgaW4gc2ltaWxhciBzdHVkaWVzLiBXZSBhaW1lZCB0byBzaG93IHRoZQogIGFkdmFudGFnZXMgb2YgaGF2aW5nIHRoZSBwcmVkaWN0aW9uIGludGVydmFsIHJvdXRpbmVseSByZXBvcnRlZCBpbgogIG1ldGEtYW5hbHlzZXMuIERFU0lHTjogV2Ugc2hvdyBob3cgdGhlIHByZWRpY3Rpb24gaW50ZXJ2YWwgY2FuIGhlbHAgdW5kZXJzdGFuZAogIHRoZSB1bmNlcnRhaW50eSBhYm91dCB3aGV0aGVyIGFuIGludGVydmVudGlvbiB3b3JrcyBvciBub3QuIFRvIGV2YWx1YXRlIHRoZQogIGltcGxpY2F0aW9ucyBvZiB1c2luZyB0aGlzIGludGVydmFsIHRvIGludGVycHJldCB0aGUgcmVzdWx0cywgd2Ugc2VsZWN0ZWQgdGhlCiAgZmlyc3QgbWV0YS1hbmFseXNpcyBwZXIgaW50ZXJ2ZW50aW9uIHJldmlldyBvZiB0aGUgQ29jaHJhbmUgRGF0YWJhc2Ugb2YKICBTeXN0ZW1hdGljIFJldmlld3MgSXNzdWVzIDIwMDktMjAxMyB3aXRoIGEgZGljaG90b21vdXMgKG49MjAwOSkgb3IgY29udGludW91cwogIChuPTEyNTQpIG91dGNvbWUsIGFuZCBnZW5lcmF0ZWQgOTVcJSBwcmVkaWN0aW9uIGludGVydmFscyBmb3IgdGhlbS4gUkVTVUxUUzoKICBJbiA3Mi40XCUgb2YgNDc5IHN0YXRpc3RpY2FsbHkgc2lnbmlmaWNhbnQgKHJhbmRvbS1lZmZlY3RzIHAwKSwgdGhlIDk1XCUKICBwcmVkaWN0aW9uIGludGVydmFsIHN1Z2dlc3RlZCB0aGF0IHRoZSBpbnRlcnZlbnRpb24gZWZmZWN0IGNvdWxkIGJlIG51bGwgb3IKICBldmVuIGJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uIEluIDIwLjNcJSBvZiB0aG9zZSA0NzkgbWV0YS1hbmFseXNlcywgdGhlCiAgcHJlZGljdGlvbiBpbnRlcnZhbCBzaG93ZWQgdGhhdCB0aGUgZWZmZWN0IGNvdWxkIGJlIGNvbXBsZXRlbHkgb3Bwb3NpdGUgdG8gdGhlCiAgcG9pbnQgZXN0aW1hdGUgb2YgdGhlIG1ldGEtYW5hbHlzaXMuIFdlIGRlbW9uc3RyYXRlIGFsc28gaG93IHRoZSBwcmVkaWN0aW9uCiAgaW50ZXJ2YWwgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBwcm9iYWJpbGl0eSB0aGF0IGEgbmV3IHRyaWFsIHdpbGwgc2hvdyBhCiAgbmVnYXRpdmUgZWZmZWN0IGFuZCB0byBpbXByb3ZlIHRoZSBjYWxjdWxhdGlvbnMgb2YgdGhlIHBvd2VyIG9mIGEgbmV3IHRyaWFsLgogIENPTkNMVVNJT05TOiBUaGUgcHJlZGljdGlvbiBpbnRlcnZhbCByZWZsZWN0cyB0aGUgdmFyaWF0aW9uIGluIHRyZWF0bWVudAogIGVmZmVjdHMgb3ZlciBkaWZmZXJlbnQgc2V0dGluZ3MsIGluY2x1ZGluZyB3aGF0IGVmZmVjdCBpcyB0byBiZSBleHBlY3RlZCBpbgogIGZ1dHVyZSBwYXRpZW50cywgc3VjaCBhcyB0aGUgcGF0aWVudHMgdGhhdCBhIGNsaW5pY2lhbiBpcyBpbnRlcmVzdGVkIHRvIHRyZWF0LgogIFByZWRpY3Rpb24gaW50ZXJ2YWxzIHNob3VsZCBiZSByb3V0aW5lbHkgcmVwb3J0ZWQgdG8gYWxsb3cgbW9yZSBpbmZvcm1hdGl2ZQogIGluZmVyZW5jZXMgaW4gbWV0YS1hbmFseXNlcy59LAogIHVybCA9IHtodHRwOi8vZHguZG9pLm9yZy8xMC4xMTM2L2Jtam9wZW4tMjAxNS0wMTAyNDd9LAogIGtleXdvcmRzID0ge0NsaW5pY2FsIHRyaWFsOyBDb2NocmFuZSBEYXRhYmFzZSBvZiBTeXN0ZW1hdGljIFJldmlld3M7CiAgSGV0ZXJvZ2VuZWl0eTsgTWV0YS1hbmFseXNpczsgUHJlZGljdGlvbiBpbnRlcnZhbDsgUmFuZG9tIGVmZmVjdHM7QmF5ZXNpYW4KICBTdGF0aXN0aWNzfSwKICBsYW5ndWFnZSA9IHtlbn0KfQoKQEFSVElDTEV7VmV2ZWEyMDA1LXhjLAogIHRpdGxlID0ge1B1YmxpY2F0aW9uIGJpYXMgaW4gcmVzZWFyY2ggc3ludGhlc2lzOiBzZW5zaXRpdml0eSBhbmFseXNpcyB1c2luZyBhCiAgcHJpb3JpIHdlaWdodCBmdW5jdGlvbnN9LAogIGF1dGhvciA9IHtWZXZlYSwgSmFjayBMIGFuZCBXb29kcywgQ2Fyb2wgTX0sCiAgam91cm5hbHRpdGxlID0ge1BzeWNob2xvZ2ljYWwgbWV0aG9kc30sCiAgcHVibGlzaGVyID0ge0FtZXJpY2FuIFBzeWNob2xvZ2ljYWwgQXNzb2NpYXRpb24gKEFQQSl9LAogIHZvbHVtZSA9IHsxMH0sCiAgaXNzdWUgPSB7NH0sCiAgcGFnZXMgPSB7NDI4LTQ0M30sCiAgZGF0ZSA9IHsyMDA1LTEyfSwKICBkb2kgPSB7MTAuMTAzNy8xMDgyLTk4OVguMTAuNC40Mjh9LAogIHBtaWQgPSB7MTYzOTI5OTh9LAogIGlzc24gPSB7MTA4Mi05ODlYLDE5MzktMTQ2M30sCiAgYWJzdHJhY3QgPSB7UHVibGljYXRpb24gYmlhcywgc29tZXRpbWVzIGtub3duIGFzIHRoZSAiZmlsZS1kcmF3ZXIgcHJvYmxlbSIgb3IKICAiZnVubmVsLXBsb3QgYXN5bW1ldHJ5LCIgaXMgY29tbW9uIGluIGVtcGlyaWNhbCByZXNlYXJjaC4gVGhlIGF1dGhvcnMgcmV2aWV3CiAgdGhlIGltcGxpY2F0aW9ucyBvZiBwdWJsaWNhdGlvbiBiaWFzIGZvciBxdWFudGl0YXRpdmUgcmVzZWFyY2ggc3ludGhlc2lzCiAgKG1ldGEtYW5hbHlzaXMpIGFuZCBkZXNjcmliZSBleGlzdGluZyB0ZWNobmlxdWVzIGZvciBkZXRlY3RpbmcgYW5kIGNvcnJlY3RpbmcKICBpdC4gQSBuZXcgYXBwcm9hY2ggaXMgcHJvcG9zZWQgdGhhdCBpcyBzdWl0YWJsZSBmb3IgYXBwbGljYXRpb24gdG8KICBtZXRhLWFuYWx5dGljIGRhdGEgc2V0cyB0aGF0IGFyZSB0b28gc21hbGwgZm9yIHRoZSBhcHBsaWNhdGlvbiBvZiBleGlzdGluZwogIG1ldGhvZHMuIFRoZSBtb2RlbCBlc3RpbWF0ZXMgcGFyYW1ldGVycyByZWxldmFudCB0byBmaXhlZC1lZmZlY3RzLAogIG1peGVkLWVmZmVjdHMgb3IgcmFuZG9tLWVmZmVjdHMgbWV0YS1hbmFseXNpcyBjb250aW5nZW50IG9uIGEgaHlwb3RoZXRpY2FsCiAgcGF0dGVybiBvZiBiaWFzIHRoYXQgaXMgZml4ZWQgaW5kZXBlbmRlbnRseSBvZiB0aGUgZGF0YS4gVGhlIGF1dGhvcnMKICBpbGx1c3RyYXRlIHRoaXMgYXBwcm9hY2ggZm9yIHNlbnNpdGl2aXR5IGFuYWx5c2lzIHVzaW5nIDMgZGF0YSBzZXRzIGFkYXB0ZWQKICBmcm9tIGEgY29tbW9ubHkgY2l0ZWQgcmVmZXJlbmNlIHdvcmsgb24gcmVzZWFyY2ggc3ludGhlc2lzIChILiBNLiBDb29wZXIgXCYgTC4KICBWLiBIZWRnZXMsIDE5OTQpLn0sCiAgdXJsID0ge2h0dHBzOi8vcHN5Y25ldC5hcGEub3JnL3JlY29yZC8yMDA1LTE2MTM2LTAwNn0sCiAgdXJsZGF0ZSA9IHsyMDI0LTAyLTAzfSwKICBsYW5ndWFnZSA9IHtlbn0KfQoKQEFSVElDTEV7SGlnZ2luczIwMDItZmgsCiAgdGl0bGUgPSB7UXVhbnRpZnlpbmcgaGV0ZXJvZ2VuZWl0eSBpbiBhIG1ldGEtYW5hbHlzaXN9LAogIGF1dGhvciA9IHtIaWdnaW5zLCBKdWxpYW4gUCBUIGFuZCBUaG9tcHNvbiwgU2ltb24gR30sCiAgam91cm5hbHRpdGxlID0ge1N0YXRpc3RpY3MgaW4gbWVkaWNpbmV9LAogIHZvbHVtZSA9IHsyMX0sCiAgaXNzdWUgPSB7MTF9LAogIHBhZ2VzID0gezE1MzktMTU1OH0sCiAgZGF0ZSA9IHsyMDAyLTA2LTE1fSwKICBkb2kgPSB7MTAuMTAwMi9zaW0uMTE4Nn0sCiAgcG1pZCA9IHsxMjExMTkxOX0sCiAgaXNzbiA9IHswMjc3LTY3MTV9LAogIGFic3RyYWN0ID0ge1RoZSBleHRlbnQgb2YgaGV0ZXJvZ2VuZWl0eSBpbiBhIG1ldGEtYW5hbHlzaXMgcGFydGx5IGRldGVybWluZXMKICB0aGUgZGlmZmljdWx0eSBpbiBkcmF3aW5nIG92ZXJhbGwgY29uY2x1c2lvbnMuIFRoaXMgZXh0ZW50IG1heSBiZSBtZWFzdXJlZCBieQogIGVzdGltYXRpbmcgYSBiZXR3ZWVuLXN0dWR5IHZhcmlhbmNlLCBidXQgaW50ZXJwcmV0YXRpb24gaXMgdGhlbiBzcGVjaWZpYyB0byBhCiAgcGFydGljdWxhciB0cmVhdG1lbnQgZWZmZWN0IG1ldHJpYy4gQSB0ZXN0IGZvciB0aGUgZXhpc3RlbmNlIG9mIGhldGVyb2dlbmVpdHkKICBleGlzdHMsIGJ1dCBkZXBlbmRzIG9uIHRoZSBudW1iZXIgb2Ygc3R1ZGllcyBpbiB0aGUgbWV0YS1hbmFseXNpcy4gV2UgZGV2ZWxvcAogIG1lYXN1cmVzIG9mIHRoZSBpbXBhY3Qgb2YgaGV0ZXJvZ2VuZWl0eSBvbiBhIG1ldGEtYW5hbHlzaXMsIGZyb20gbWF0aGVtYXRpY2FsCiAgY3JpdGVyaWEsIHRoYXQgYXJlIGluZGVwZW5kZW50IG9mIHRoZSBudW1iZXIgb2Ygc3R1ZGllcyBhbmQgdGhlIHRyZWF0bWVudAogIGVmZmVjdCBtZXRyaWMuIFdlIGRlcml2ZSBhbmQgcHJvcG9zZSB0aHJlZSBzdWl0YWJsZSBzdGF0aXN0aWNzOiBIIGlzIHRoZQogIHNxdWFyZSByb290IG9mIHRoZSBjaGkyIGhldGVyb2dlbmVpdHkgc3RhdGlzdGljIGRpdmlkZWQgYnkgaXRzIGRlZ3JlZXMgb2YKICBmcmVlZG9tOyBSIGlzIHRoZSByYXRpbyBvZiB0aGUgc3RhbmRhcmQgZXJyb3Igb2YgdGhlIHVuZGVybHlpbmcgbWVhbiBmcm9tIGEKICByYW5kb20gZWZmZWN0cyBtZXRhLWFuYWx5c2lzIHRvIHRoZSBzdGFuZGFyZCBlcnJvciBvZiBhIGZpeGVkIGVmZmVjdAogIG1ldGEtYW5hbHl0aWMgZXN0aW1hdGUsIGFuZCBJMiBpcyBhIHRyYW5zZm9ybWF0aW9uIG9mIChIKSB0aGF0IGRlc2NyaWJlcyB0aGUKICBwcm9wb3J0aW9uIG9mIHRvdGFsIHZhcmlhdGlvbiBpbiBzdHVkeSBlc3RpbWF0ZXMgdGhhdCBpcyBkdWUgdG8gaGV0ZXJvZ2VuZWl0eS4KICBXZSBkaXNjdXNzIGludGVycHJldGF0aW9uLCBpbnRlcnZhbCBlc3RpbWF0ZXMgYW5kIG90aGVyIHByb3BlcnRpZXMgb2YgdGhlc2UKICBtZWFzdXJlcyBhbmQgZXhhbWluZSB0aGVtIGluIGZpdmUgZXhhbXBsZSBkYXRhIHNldHMgc2hvd2luZyBkaWZmZXJlbnQgYW1vdW50cwogIG9mIGhldGVyb2dlbmVpdHkuIFdlIGNvbmNsdWRlIHRoYXQgSCBhbmQgSTIsIHdoaWNoIGNhbiB1c3VhbGx5IGJlIGNhbGN1bGF0ZWQKICBmb3IgcHVibGlzaGVkIG1ldGEtYW5hbHlzZXMsIGFyZSBwYXJ0aWN1bGFybHkgdXNlZnVsIHN1bW1hcmllcyBvZiB0aGUgaW1wYWN0CiAgb2YgaGV0ZXJvZ2VuZWl0eS4gT25lIG9yIGJvdGggc2hvdWxkIGJlIHByZXNlbnRlZCBpbiBwdWJsaXNoZWQgbWV0YS1hbmFseXNlcwogIGluIHByZWZlcmVuY2UgdG8gdGhlIHRlc3QgZm9yIGhldGVyb2dlbmVpdHkufSwKICB1cmwgPSB7aHR0cDovL2R4LmRvaS5vcmcvMTAuMTAwMi9zaW0uMTE4Nn0sCiAgbGFuZ3VhZ2UgPSB7ZW59Cn0KCkBBUlRJQ0xFe0xvcGV6LUxvcGV6MjAxNC1pdCwKICB0aXRsZSA9IHtFc3RpbWF0aW9uIG9mIHRoZSBwcmVkaWN0aXZlIHBvd2VyIG9mIHRoZSBtb2RlbCBpbiBtaXhlZC1lZmZlY3RzCiAgbWV0YS1yZWdyZXNzaW9uOiBBIHNpbXVsYXRpb24gc3R1ZHl9LAogIGF1dGhvciA9IHtMw7NwZXotTMOzcGV6LCBKb3PDqSBBbnRvbmlvIGFuZCBNYXLDrW4tTWFydMOtbmV6LCBGdWxnZW5jaW8gYW5kCiAgU8OhbmNoZXotTWVjYSwgSnVsaW8gYW5kIFZhbiBkZW4gTm9vcnRnYXRlLCBXaW0gYW5kIFZpZWNodGJhdWVyLCBXb2xmZ2FuZ30sCiAgam91cm5hbHRpdGxlID0ge1RoZSBCcml0aXNoIGpvdXJuYWwgb2YgbWF0aGVtYXRpY2FsIGFuZCBzdGF0aXN0aWNhbCBwc3ljaG9sb2d5fSwKICBwdWJsaXNoZXIgPSB7V2lsZXl9LAogIHZvbHVtZSA9IHs2N30sCiAgaXNzdWUgPSB7MX0sCiAgcGFnZXMgPSB7MzAtNDh9LAogIGRhdGUgPSB7MjAxNC0wMn0sCiAgZG9pID0gezEwLjExMTEvYm1zcC4xMjAwMn0sCiAgcG1pZCA9IHsyMzI5NzcwOX0sCiAgaXNzbiA9IHswMDA3LTExMDIsMjA0NC04MzE3fSwKICBhYnN0cmFjdCA9IHtTZXZlcmFsIG1ldGhvZHMgYXJlIGF2YWlsYWJsZSB0byBlc3RpbWF0ZSB0aGUgdG90YWwgYW5kIHJlc2lkdWFsCiAgYW1vdW50IG9mIGhldGVyb2dlbmVpdHkgaW4gbWV0YS1hbmFseXNpcywgbGVhZGluZyB0byBkaWZmZXJlbnQgYWx0ZXJuYXRpdmVzCiAgd2hlbiBlc3RpbWF0aW5nIHRoZSBwcmVkaWN0aXZlIHBvd2VyIGluIG1peGVkLWVmZmVjdHMgbWV0YS1yZWdyZXNzaW9uIG1vZGVscwogIHVzaW5nIHRoZSBmb3JtdWxhIHByb3Bvc2VkIGJ5IFJhdWRlbmJ1c2ggKDE5OTQsIDIwMDkpLiBJbiB0aGlzIHBhcGVyLCBhCiAgc2ltdWxhdGlvbiBzdHVkeSB3YXMgY29uZHVjdGVkIHRvIGNvbXBhcmUgdGhlIHBlcmZvcm1hbmNlIG9mIHNldmVuIGVzdGltYXRvcnMKICBvZiB0aGVzZSBwYXJhbWV0ZXJzIHVuZGVyIHZhcmlvdXMgcmVhbGlzdGljIHNjZW5hcmlvcyBpbiBwc3ljaG9sb2d5IGFuZAogIHJlbGF0ZWQgZmllbGRzLiBPdXIgcmVzdWx0cyBzdWdnZXN0IHRoYXQgdGhlIG51bWJlciBvZiBzdHVkaWVzIChrKSBleGVydHMgdGhlCiAgbW9zdCBpbXBvcnRhbnQgaW5mbHVlbmNlIG9uIHRoZSBhY2N1cmFjeSBvZiB0aGUgcmVzdWx0cywgYW5kIHRoYXQgcHJlY2lzZQogIGVzdGltYXRlcyBvZiB0aGUgaGV0ZXJvZ2VuZWl0eSB2YXJpYW5jZXMgYW5kIHRoZSBtb2RlbCBwcmVkaWN0aXZlIHBvd2VyIGNhbgogIG9ubHkgYmUgZXhwZWN0ZWQgd2l0aCBhdCBsZWFzdCAyMCBhbmQgNDAgc3R1ZGllcywgcmVzcGVjdGl2ZWx5LiBJbmNyZWFzZXMgaW4KICB0aGUgYXZlcmFnZSB3aXRoaW4tc3R1ZHkgc2FtcGxlIHNpemUgKE7CrykgYWxzbyBpbXByb3ZlZCB0aGUgcmVzdWx0cyBmb3IgYWxsCiAgZXN0aW1hdG9ycy4gU29tZSBkaWZmZXJlbmNlcyBhbW9uZyB0aGUgYWNjdXJhY3kgb2YgdGhlIGVzdGltYXRvcnMgd2VyZQogIG9ic2VydmVkLCBlc3BlY2lhbGx5IHVuZGVyIGFkdmVyc2UgKHNtYWxsIGsgYW5kIE7CrykgY29uZGl0aW9ucywgd2hpbGUgdGhlCiAgcmVzdWx0cyBmb3IgdGhlIGRpZmZlcmVudCBtZXRob2RzIHRlbmRlZCB0byBjb252ZXJnZW5jZSBmb3IgbW9yZSBvcHRpbWFsCiAgc2NlbmFyaW9zLn0sCiAgdXJsID0ge2h0dHBzOi8vYnBzcHN5Y2h1Yi5vbmxpbmVsaWJyYXJ5LndpbGV5LmNvbS9kb2kvYWJzLzEwLjExMTEvYm1zcC4xMjAwMn0sCiAgbGFuZ3VhZ2UgPSB7ZW59Cn0KCkBCT09Le0dlbG1hbjIwMjAtdGcsCiAgdGl0bGUgPSB7UmVncmVzc2lvbiBhbmQgT3RoZXIgU3Rvcmllc30sCiAgYXV0aG9yID0ge0dlbG1hbiwgQW5kcmV3IGFuZCBIaWxsLCBKZW5uaWZlciBhbmQgVmVodGFyaSwgQWtpfSwKICBwdWJsaXNoZXIgPSB7Q2FtYnJpZGdlIFVuaXZlcnNpdHkgUHJlc3N9LAogIGRhdGUgPSB7MjAyMC0wNy0yM30sCiAgZG9pID0gezEwLjEwMTcvOTc4MTEzOTE2MTg3OX0sCiAgaXNibiA9IHs5NzgxMTM5MTYxODc5fSwKICBhYnN0cmFjdCA9IHtNb3N0IHRleHRib29rcyBvbiByZWdyZXNzaW9uIGZvY3VzIG9uIHRoZW9yeSBhbmQgdGhlIHNpbXBsZXN0IG9mCiAgZXhhbXBsZXMuIFJlYWwgc3RhdGlzdGljYWwgcHJvYmxlbXMsIGhvd2V2ZXIsIGFyZSBjb21wbGV4IGFuZCBzdWJ0bGUuIFRoaXMgaXMKICBub3QgYSBib29rIGFib3V0IHRoZSB0aGVvcnkgb2YgcmVncmVzc2lvbi4gSXQgaXMgYWJvdXQgdXNpbmcgcmVncmVzc2lvbiB0bwogIHNvbHZlIHJlYWwgcHJvYmxlbXMgb2YgY29tcGFyaXNvbiwgZXN0aW1hdGlvbiwgcHJlZGljdGlvbiwgYW5kIGNhdXNhbAogIGluZmVyZW5jZS4gVW5saWtlIG90aGVyIGJvb2tzLCBpdCBmb2N1c2VzIG9uIHByYWN0aWNhbCBpc3N1ZXMgc3VjaCBhcyBzYW1wbGUKICBzaXplIGFuZCBtaXNzaW5nIGRhdGEgYW5kIGEgd2lkZSByYW5nZSBvZiBnb2FscyBhbmQgdGVjaG5pcXVlcy4gSXQganVtcHMgcmlnaHQKICBpbiB0byBtZXRob2RzIGFuZCBjb21wdXRlciBjb2RlIHlvdSBjYW4gdXNlIGltbWVkaWF0ZWx5LiBSZWFsIGV4YW1wbGVzLCByZWFsCiAgc3RvcmllcyBmcm9tIHRoZSBhdXRob3JzJyBleHBlcmllbmNlIGRlbW9uc3RyYXRlIHdoYXQgcmVncmVzc2lvbiBjYW4gZG8gYW5kCiAgaXRzIGxpbWl0YXRpb25zLCB3aXRoIHByYWN0aWNhbCBhZHZpY2UgZm9yIHVuZGVyc3RhbmRpbmcgYXNzdW1wdGlvbnMgYW5kCiAgaW1wbGVtZW50aW5nIG1ldGhvZHMgZm9yIGV4cGVyaW1lbnRzIGFuZCBvYnNlcnZhdGlvbmFsIHN0dWRpZXMuIFRoZXkgbWFrZSBhCiAgc21vb3RoIHRyYW5zaXRpb24gdG8gbG9naXN0aWMgcmVncmVzc2lvbiBhbmQgR0xNLiBUaGUgZW1waGFzaXMgaXMgb24KICBjb21wdXRhdGlvbiBpbiBSIGFuZCBTdGFuIHJhdGhlciB0aGFuIGRlcml2YXRpb25zLCB3aXRoIGNvZGUgYXZhaWxhYmxlIG9ubGluZS4KICBHcmFwaGljcyBhbmQgcHJlc2VudGF0aW9uIGFpZCB1bmRlcnN0YW5kaW5nIG9mIHRoZSBtb2RlbHMgYW5kIG1vZGVsIGZpdHRpbmcufSwKICB1cmwgPSB7aHR0cHM6Ly93d3cuY2FtYnJpZGdlLm9yZy9oaWdoZXJlZHVjYXRpb24vYm9va3MvcmVncmVzc2lvbi1hbmQtb3RoZXItc3Rvcmllcy9ERDIwREQ2QzkwNTcxMTg1ODEwNzZFNTRFNDBDMzcyQ30sCiAgdXJsZGF0ZSA9IHsyMDIzLTAyLTE0fQp9CgpAQVJUSUNMRXtIZWRnZXMxOTg5LWlwLAogIHRpdGxlID0ge0FuIHVuYmlhc2VkIGNvcnJlY3Rpb24gZm9yIHNhbXBsaW5nIGVycm9yIGluIHZhbGlkaXR5IGdlbmVyYWxpemF0aW9uCiAgc3R1ZGllc30sCiAgYXV0aG9yID0ge0hlZGdlcywgTGFycnkgVn0sCiAgam91cm5hbHRpdGxlID0ge1RoZSBKb3VybmFsIG9mIGFwcGxpZWQgcHN5Y2hvbG9neX0sCiAgcHVibGlzaGVyID0ge0FtZXJpY2FuIFBzeWNob2xvZ2ljYWwgQXNzb2NpYXRpb24gKEFQQSl9LAogIHZvbHVtZSA9IHs3NH0sCiAgaXNzdWUgPSB7M30sCiAgcGFnZXMgPSB7NDY5LTQ3N30sCiAgZGF0ZSA9IHsxOTg5LTA2fSwKICBkb2kgPSB7MTAuMTAzNy8wMDIxLTkwMTAuNzQuMy40Njl9LAogIGlzc24gPSB7MDAyMS05MDEwLDE5MzktMTg1NH0sCiAgdXJsID0ge2h0dHA6Ly9keC5kb2kub3JnLzEwLjEwMzcvMDAyMS05MDEwLjc0LjMuNDY5fSwKICBsYW5ndWFnZSA9IHtlbn0KfQoKQEFSVElDTEV7SGVkZ2VzMjAxOS1yeSwKICB0aXRsZSA9IHtTdGF0aXN0aWNhbCBhbmFseXNlcyBmb3Igc3R1ZHlpbmcgcmVwbGljYXRpb246IE1ldGEtYW5hbHl0aWMKICBwZXJzcGVjdGl2ZXN9LAogIGF1dGhvciA9IHtIZWRnZXMsIExhcnJ5IFYgYW5kIFNjaGF1ZXIsIEphY29iIE19LAogIGpvdXJuYWx0aXRsZSA9IHtQc3ljaG9sb2dpY2FsIG1ldGhvZHN9LAogIHB1Ymxpc2hlciA9IHtBbWVyaWNhbiBQc3ljaG9sb2dpY2FsIEFzc29jaWF0aW9uIChBUEEpfSwKICB2b2x1bWUgPSB7MjR9LAogIGlzc3VlID0gezV9LAogIHBhZ2VzID0gezU1Ny01NzB9LAogIGRhdGUgPSB7MjAxOS0xMH0sCiAgZG9pID0gezEwLjEwMzcvbWV0MDAwMDE4OX0sCiAgcG1pZCA9IHszMDA3MDU0N30sCiAgaXNzbiA9IHsxMDgyLTk4OVgsMTkzOS0xNDYzfSwKICBhYnN0cmFjdCA9IHtGb3JtYWwgZW1waXJpY2FsIGFzc2Vzc21lbnRzIG9mIHJlcGxpY2F0aW9uIGhhdmUgcmVjZW50bHkgYmVjb21lCiAgbW9yZSBwcm9taW5lbnQgaW4gc2V2ZXJhbCBhcmVhcyBvZiBzY2llbmNlLCBpbmNsdWRpbmcgcHN5Y2hvbG9neS4gVGhlc2UKICBhc3Nlc3NtZW50cyBoYXZlIHVzZWQgZGlmZmVyZW50IHN0YXRpc3RpY2FsIGFwcHJvYWNoZXMgdG8gZGV0ZXJtaW5lIGlmIGEKICBmaW5kaW5nIGhhcyBiZWVuIHJlcGxpY2F0ZWQuIFRoZSBwdXJwb3NlIG9mIHRoaXMgYXJ0aWNsZSBpcyB0byBwcm92aWRlIHNldmVyYWwKICBhbHRlcm5hdGl2ZSBjb25jZXB0dWFsIGZyYW1ld29ya3MgdGhhdCBsZWFkIHRvIGRpZmZlcmVudCBzdGF0aXN0aWNhbCBhbmFseXNlcwogIHRvIHRlc3QgaHlwb3RoZXNlcyBhYm91dCByZXBsaWNhdGlvbi4gQWxsIG9mIHRoZXNlIGFuYWx5c2VzIGFyZSBiYXNlZCBvbgogIHN0YXRpc3RpY2FsIG1ldGhvZHMgdXNlZCBpbiBtZXRhLWFuYWx5c2lzLiBUaGUgZGlmZmVyZW5jZXMgYW1vbmcgdGhlIG1ldGhvZHMKICBkZXNjcmliZWQgaW52b2x2ZSB3aGV0aGVyIHRoZSBidXJkZW4gb2YgcHJvb2YgaXMgcGxhY2VkIG9uIHJlcGxpY2F0aW9uIG9yCiAgbm9ucmVwbGljYXRpb24sIHdoZXRoZXIgcmVwbGljYXRpb24gaXMgZXhhY3Qgb3IgYWxsb3dzIGZvciBhIHNtYWxsIGFtb3VudCBvZgogICJuZWdsaWdpYmxlIGhldGVyb2dlbmVpdHksIiBhbmQgd2hldGhlciB0aGUgc3R1ZGllcyBvYnNlcnZlZCBhcmUgYXNzdW1lZCB0byBiZQogIGZpeGVkIChjb25zdGl0dXRpbmcgdGhlIGVudGlyZSBib2R5IG9mIHJlbGV2YW50IGV2aWRlbmNlKSBvciBhcmUgYSBzYW1wbGUgZnJvbQogIGEgdW5pdmVyc2Ugb2YgcG9zc2libHkgcmVsZXZhbnQgc3R1ZGllcy4gVGhlIHN0YXRpc3RpY2FsIHBvd2VyIG9mIGVhY2ggb2YKICB0aGVzZSB0ZXN0cyBpcyBjb21wdXRlZCBhbmQgc2hvd24gdG8gYmUgbG93IGluIG1hbnkgY2FzZXMsIHJhaXNpbmcgaXNzdWVzIG9mCiAgdGhlIGludGVycHJldGFiaWxpdHkgb2YgdGVzdHMgZm9yIHJlcGxpY2F0aW9uLiAoUHN5Y0lORk8gRGF0YWJhc2UgUmVjb3JkIChjKQogIDIwMTkgQVBBLCBhbGwgcmlnaHRzIHJlc2VydmVkKS59LAogIHVybCA9IHtodHRwOi8vZHguZG9pLm9yZy8xMC4xMDM3L21ldDAwMDAxODl9LAogIGZpbGUgPSB7SGVkZ2VzIGFuZCBTY2hhdWVyIDIwMTkgLSBTdGF0aXN0aWNhbCBhbmFseXNlcyBmb3Igc3R1ZHlpbmcgcmVwbGljYXRpb24gLSBNZXRhLWFuYWx5dGljIHBlcnNwZWN0aXZlcy5wZGZ9LAogIGtleXdvcmRzID0ge3JlcGxpY2FiaWxpdHktYm9vazttZXRob2RzfSwKICBsYW5ndWFnZSA9IHtlbn0KfQoK\" download=\"refs_to_download.bib\"> Download .bib file</a></button> {.refs}\n\n::: {#refs}\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}